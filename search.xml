<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[跨域问题及其解决]]></title>
    <url>%2Fhexo%2F2018%2F07%2F25%2Fcross-origin%2F</url>
    <content type="text"><![CDATA[跨域问题及其解决产生跨域问题的原因跨域问题是由于浏览器同源策略，同源策略限制从一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的关键的安全机制。 一个源的定义:如果协议，端口（如果指定了一个）和域名对于两个页面是相同的，则两个页面具有相同的源。 如https://www.github.com:80,https是协议，80是端口，www.github.com是域名。有一个不同，则不同源。 下表给出了相对http://store.company.com/dir/page.html同源检测的示例: URL 结果 原因 http://store.company.com/dir2/other.html 成功 dir2/other.html http://store.company.com/dir/inner/another.html 成功 dir/inner/another.html http://store.company.com/dir/inner/another.html 失败 不同的协议 ( https ) http://store.company.com:81/dir/etc.html 失败 不同的端口 ( 81 ) http://news.company.com/dir/other.html 失败 不同的域名 ( news ) 解決方法 1、使用jsonp 2、服务端代理 在服务器端设置一个代理，由服务器端向跨域下的网站发出请求，再将请求结果返回给前端，成功避免同源策略的限制。 3、HTTP访问控制CORS 设置Access-Control-Allow-Origin。]]></content>
      <categories>
        <category>Http</category>
      </categories>
      <tags>
        <tag>Cross Origin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Contest 47]]></title>
    <url>%2Fhexo%2F2018%2F07%2F25%2FContest47%2F</url>
    <content type="text"><![CDATA[LeetCode Contest 47记录下做题思路。 665.Non-decreasing ArrayGiven an array with n integers, your task is to check if it could become non-decreasing by modifying at most 1 element. We define an array is non-decreasing if array[i] &lt;= array[i + 1] holds for every i (1 &lt;= i &lt; n). Example 1: 123Input: [4,2,3]Output: TrueExplanation: You could modify the first 4 to 1 to get a non-decreasing array. Example 2: 123Input: [4,2,1]Output: FalseExplanation: You can&apos;t get a non-decreasing array by modify at most one element. 123456789101112131415161718/** * @param &#123;number[]&#125; nums * @return &#123;boolean&#125; */var checkPossibility = function(nums) &#123; let flag = true; for(let i=1;i&lt;nums.length; i++)&#123; if(nums[i] &lt; nums[i-1])&#123; if(!flag) return flag; if(i&gt;1&amp;&amp; nums[i] &lt; nums[i-2]) &#123;// 如果当前这个数比前2个数都小，就删去，然后继续判断 nums.splice(i,1); i--; &#125; flag = false;//否则，当前数比之前小，但比i-2要大，那么在当前数上继续判断 &#125; &#125; return true;&#125;; 666. Path Sum IVIf the depth of a tree is smaller than 5, then this tree can be represented by a list of three-digits integers. For each integer in this list: The hundreds digit represents the depth D of this node, 1 &lt;= D &lt;= 4. The tens digit represents the position P of this node in the level it belongs to, 1 &lt;= P &lt;= 8. The position is the same as that in a full binary tree. The units digit represents the value V of this node, 0 &lt;= V &lt;= 9. Given a list of ascending three-digits integers representing a binary with the depth smaller than 5. You need to return the sum of all paths from the root towards the leaves. 1234567891011121314151617181920212223var pathSum = function(nums,sum=0) &#123; if(!nums || nums.length===0) return 0; let root = nums[0]%100%10; if(nums.length === 1) return root+sum; let left=[],right=[]; for(let i=1; i&lt; nums.length; i++)&#123;、 //LorR：十位数，标志是左子树还是右子树 //level：当前在第几层 let LorR = ~~(nums[i]%100/10), level = ~~(nums[i]/100); //分别放入左右子树数组，并对百位数-100，如果是右子树，十位数减去左边的个数 if(LorR &lt;= Math.pow(2,level-2)) left.push(nums[i]-100); else right.push(nums[i]-100 - 10 * Math.pow(2,level-2)); &#125; let res = 0; if(left.length)&#123; res += pathSum(left,root+sum); //递归调用，传入当前和 &#125; if(right.length)&#123; res += pathSum(right,root+sum); &#125; return res;&#125;; 667.Beautiful Arrangement IIGiven two integers n and k, you need to construct a list which contains n different positive integers ranging from 1 to n and obeys the following requirement:Suppose this list is [a1, a2, a3, … , an], then the list [|a1 - a2|, |a2 - a3|, |a3 - a4|, … , |an-1 - an|] has exactly k distinct integers. If there are multiple answers, print any of them. Example 1: 123Input: n = 3, k = 1Output: [1, 2, 3]Explanation: The [1, 2, 3] has three different positive integers ranging from 1 to 3, and the [1, 1] has exactly 1 distinct integer: 1. Example 2: 123Input: n = 3, k = 2Output: [1, 3, 2]Explanation: The [1, 3, 2] has three different positive integers ranging from 1 to 3, and the [2, 1] has exactly 2 distinct integers: 1 and 2. 1234567891011121314151617181920/** * @param &#123;number&#125; n * @param &#123;number&#125; k * @return &#123;number[]&#125; */var constructArray = function(n, k) &#123; let res = []; for(let i=0;i&lt;n;i++) res[i] = i+1; if(k===1) return res; let i = 1, sign = true; //有k个不同差值，那就从1到k，对1-n中前k个数进行变换 while(k &gt; 0)&#123; if(sign) res[i] = res[i-1] + k; // 1,1+k,1+k-(k-1)... else res[i] = res[i-1] - k; k--; i++; sign = !sign; &#125; return res;&#125;; 668. Kth largest Number in Multiplication Table Nearly every one have used the Multiplication Table. But could you find out the k-th largest number quickly from the multiplication table? Given the height m and the length n of a m * n Multiplication Table, and a positive integer k, you need to return the k-th largest number in this table. Example 1: 123456789Input: m = 3, n = 3, k = 5Output: Explanation: The Multiplication Table:1 2 32 4 63 6 9The 5-th largest number is 3 (1, 2, 2, 3, 3). Example 2: 12345678Input: m = 2, n = 3, k = 6Output: Explanation: The Multiplication Table:1 2 32 4 6The 6-th largest number is 6 (1, 2, 2, 3, 4, 6). 1234567891011121314151617181920212223/** * @param &#123;number&#125; m * @param &#123;number&#125; n * @param &#123;number&#125; k * @return &#123;number&#125; */var findKthNumber = function(m, n, k) &#123; let low = 1, high = m * n; while (low != high) &#123; let mid =~~((low + high) / 2); let cnt = 0; for (let i = 1; i &lt;= m; ++i) &#123; cnt += Math.min(~~(mid / i), n); &#125; if (cnt &lt; k) &#123; low = mid + 1; &#125; else &#123; high = mid; &#125; &#125; return high;&#125;;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[缓存]]></title>
    <url>%2Fhexo%2F2018%2F07%2F25%2Fcache%2F</url>
    <content type="text"><![CDATA[缓存介绍缓存的好文 HTTP报文浏览器向服务器请求数据，发送请求(request)报文；服务器向浏览器返回数据，返回响应(response)报文。报文信息主要分为两部分 1.包含属性的首部(header)————————–附加信息（cookie，缓存信息等）与缓存相关的规则信息，均包含在header中 2.包含数据的主体部分(body)———————–HTTP请求真正想要传输的部分 缓存规则HTTP缓存有多种规则，根据是否需要重新向服务器发起请求来分类，可将其分为两大类(强制缓存，对比缓存) 强制缓存如果生效，不需要再和服务器发生交互，而对比缓存不管是否生效，都需要与服务端发生交互。 两类缓存规则可以同时存在，强制缓存优先级高于对比缓存，也就是说，当执行强制缓存的规则时，如果缓存生效，直接使用缓存，不再执行对比缓存规则。 强制缓存对于强制缓存来说，响应header中会有两个字段来标明失效规则（Expires/Cache-Control） Expires Expires的值为服务端返回的到期时间，即下一次请求时，请求时间小于服务端返回的到期时间，直接使用缓存数据。不过Expires 是HTTP 1.0的东西，现在默认浏览器均默认使用HTTP 1.1，所以它的作用基本忽略。另一个问题是，到期时间是由服务端生成的，但是客户端时间可能跟服务端时间有误差，这就会导致缓存命中的误差。所以HTTP 1.1 的版本，使用Cache-Control替代。 Cache-ControlCache-Control 是最重要的规则。常见的取值有private、public、no-cache、max-age，no-store，默认为private。private: 客户端可以缓存public: 客户端和代理服务器都可缓存（前端的同学，可以认为public和private是一样的）max-age=xxx: 缓存的内容将在 xxx 秒后失效no-cache: 需要使用对比缓存来验证缓存数据（后面介绍）no-store: 所有内容都不会缓存，强制缓存，对比缓存都不会触发 对比缓存浏览器第一次请求数据时，服务器会将缓存标识与数据一起返回给客户端，客户端将二者备份至缓存数据库中。 再次请求数据时，客户端将备份的缓存标识发送给服务器，服务器根据缓存标识进行判断，判断成功后，返回304状态码，通知客户端比较成功，可以使用缓存数据。 对于对比缓存来说，缓存标识的传递是我们着重需要理解的，它在请求header和响应header间进行传递，一共分为两种标识传递。 Last-Modified / If-Modified-SinceLast-Modified：服务器在响应请求时，告诉浏览器资源的最后修改时间。 If-Modified-Since：再次请求服务器时，通过此字段通知服务器上次请求时，服务器返回的资源最后修改时间。 服务器收到请求后发现有头If-Modified-Since 则与被请求资源的最后修改时间进行比对。 若资源的最后修改时间大于If-Modified-Since，说明资源又被改动过，则响应整片资源内容，返回状态码200； 若资源的最后修改时间小于或等于If-Modified-Since，说明资源无新修改，则响应HTTP 304，告知浏览器继续使用所保存的cache。 Etag / If-None-Match（优先级高于Last-Modified / If-Modified-Since）Etag：服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器决定）。 If-None-Match：再次请求服务器时，通过此字段通知服务器客户段缓存数据的唯一标识。服务器收到请求后发现有头If-None-Match 则与被请求资源的唯一标识进行比对，不同，说明资源又被改动过，则响应整片资源内容，返回状态码200；相同，说明资源无新修改，则响应HTTP 304，告知浏览器继续使用所保存的cache。 总结 对于强制缓存，服务器通知浏览器一个缓存时间，在缓存时间内，下次请求，直接用缓存，不在时间内，执行比较缓存策略。 对于比较缓存，将缓存信息中的Etag和Last-Modified通过请求发送给服务器，由服务器校验，返回304状态码时，浏览器直接使用缓存。]]></content>
      <categories>
        <category>Http</category>
      </categories>
      <tags>
        <tag>cache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AJAX如何实现]]></title>
    <url>%2Fhexo%2F2018%2F07%2F25%2Fajax%2F</url>
    <content type="text"><![CDATA[AJAX如何实现参考 ajax的技术核心是 XMLHttpRequest 对象； ajax 请求过程：创建 XMLHttpRequest 对象、连接服务器、发送请求、接收响应数据； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758ajax(&#123; url: "./TestXHR.aspx", //请求地址 type: "POST", //请求方式 data: &#123; name: "super", age: 20 &#125;, //请求参数 dataType: "json", success: function (response, xml) &#123; // 此处放成功后执行的代码 &#125;, fail: function (status) &#123; // 此处放失败后执行的代码 &#125; &#125;); function ajax(options) &#123; options = options || &#123;&#125;; options.type = (options.type || "GET").toUpperCase(); options.dataType = options.dataType || "json"; var params = formatParams(options.data); //创建 - 非IE6 - 第一步 if (window.XMLHttpRequest) &#123; var xhr = new XMLHttpRequest(); &#125; else &#123; //IE6及其以下版本浏览器 var xhr = new ActiveXObject('Microsoft.XMLHTTP'); &#125; //接收 - 第三步 xhr.onreadystatechange = function () &#123; if (xhr.readyState == 4) &#123; var status = xhr.status; if (status &gt;= 200 &amp;&amp; status &lt; 300) &#123; options.success &amp;&amp; options.success(xhr.responseText, xhr.responseXML); &#125; else &#123; options.fail &amp;&amp; options.fail(status); &#125; &#125; &#125; //连接 和 发送 - 第二步 if (options.type == "GET") &#123; xhr.open("GET", options.url + "?" + params, true); xhr.send(null); &#125; else if (options.type == "POST") &#123; xhr.open("POST", options.url, true); //设置表单提交时的内容类型 xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded"); xhr.send(params); &#125; &#125; //格式化参数 function formatParams(data) &#123; var arr = []; for (var name in data) &#123; arr.push(encodeURIComponent(name) + "=" + encodeURIComponent(data[name])); &#125; arr.push(("v=" + Math.random()).replace(".","")); return arr.join("&amp;"); &#125; 1、创建1.1、IE7及其以上版本中支持原生的 XHR 对象，因此可以直接用： var oAjax = new XMLHttpRequest(); 1.2、IE6及其之前的版本中，XHR对象是通过MSXML库中的一个ActiveX对象实现的。有的书中细化了IE中此类对象的三种不同版本，即MSXML2.XMLHttp、MSXML2.XMLHttp.3.0 和 MSXML2.XMLHttp.6.0；个人感觉太麻烦，可以直接使用下面的语句创建： var oAjax=new ActiveXObject(’Microsoft.XMLHTTP’); 2、连接和发送2.1、open()函数的三个参数：请求方式、请求地址、是否异步请求(同步请求的情况极少，至今还没用到过)； 2.2、GET 请求方式是通过URL参数将数据提交到服务器的，POST则是通过将数据作为 send 的参数提交到服务器； 2.3、POST 请求中，在发送数据之前，要设置表单提交的内容类型； 2.4、提交到服务器的参数必须经过 encodeURIComponent() 方法进行编码，实际上在参数列表”key=value”的形式中，key 和 value 都需要进行编码，因为会包含特殊字符。每次请求的时候都会在参数列表中拼入一个 “v=xx” 的字符串，这样是为了拒绝缓存，每次都直接请求到服务器上。 encodeURI() ：用于整个 URI 的编码，不会对本身属于 URI 的特殊字符进行编码，如冒号、正斜杠、问号和井号；其对应的解码函数 decodeURI()；encodeURIComponent() ：用于对 URI 中的某一部分进行编码，会对它发现的任何非标准字符进行编码；其对应的解码函数 decodeURIComponent()； 3、接收3.1、接收到响应后，响应的数据会自动填充XHR对象，相关属性如下responseText：响应返回的主体内容，为字符串类型；responseXML：如果响应的内容类型是 “text/xml” 或 “application/xml”，这个属性中将保存着相应的xml 数据，是 XML 对应的 document 类型；status：响应的HTTP状态码；statusText：HTTP状态的说明； 3.2、XHR对象的readyState属性表示请求/响应过程的当前活动阶段，这个属性的值如下0-未初始化，尚未调用open()方法；1-启动，调用了open()方法，未调用send()方法；2-发送，已经调用了send()方法，未接收到响应；3-接收，已经接收到部分响应数据；4-完成，已经接收到全部响应数据； 只要 readyState 的值变化，就会调用 readystatechange 事件，(其实为了逻辑上通顺，可以把readystatechange放到send之后，因为send时请求服务器，会进行网络通信，需要时间，在send之后指定readystatechange事件处理程序也是可以的，我一般都是这样用，但为了规范和跨浏览器兼容性，还是在open之前进行指定吧)。 3.3、在readystatechange事件中，先判断响应是否接收完成，然后判断服务器是否成功处理请求，xhr.status 是状态码，状态码以2开头的都是成功，304表示从缓存中获取，上面的代码在每次请求的时候都加入了随机数，所以不会从缓存中取值，故该状态不需判断。 4、ajax请求是不能跨域的！]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2Fhexo%2F2018%2F07%2F25%2Freact-component%2F</url>
    <content type="text"><![CDATA[class组件和无状态函数组件React有三种定义react组件的方式，殊途同归；具体的三种方式： 函数式定义的无状态组件 es5原生方式React.createClass定义的组件 es6形式的extends React.Component定义的组件 无状态函数式组件创建无状态函数式组件形式是从React 0.14版本开始出现的。它是为了创建纯展示组件，这种组件只负责根据传入的props来展示，不涉及到要state状态的操作。具体的无状态函数式组件，其官方指出： 在大部分React代码中，大多数组件被写成无状态的组件，通过简单组合可以构建成其他的组件等；这种通过多个简单然后合并成一个大应用的设计模式被提倡。 无状态函数式组件形式上表现为一个只带有一个render方法的组件类，通过函数形式或者ES6 arrow function的形式在创建，并且该组件是无state状态的。具体的创建形式如下： 1234function HelloComponent(props, /* context */) &#123; return &lt;div&gt;Hello &#123;props.name&#125;&lt;/div&gt;&#125;ReactDOM.render(&lt;HelloComponent name="Sebastian" /&gt;, mountNode) 无状态组件的创建形式使代码的可读性更好，并且减少了大量冗余的代码，精简至只有一个render方法，大大的增强了编写一个组件的便利，除此之外无状态组件还有以下几个显著的特点： 组件不会被实例化，整体渲染性能得到提升 因为组件被精简成一个render方法的函数来实现的，由于是无状态组件，所以无状态组件就不会在有组件实例化的过程，无实例化过程也就不需要分配多余的内存，从而性能得到一定的提升。 组件不能访问this对象 无状态组件由于没有实例化过程，所以无法访问组件this中的对象，例如： this.ref 、this.state 等均不能访问。若想访问就不能使用这种形式来创建组件 组件无法访问生命周期的方法 因为无状态组件是不需要组件生命周期管理和状态管理，所以底层实现这种形式的组件时是不会实现组件的生命周期方法。所以无状态组件是不能参与组件的各个生命周期管理的。 无状态组件只能访问输入的props，同样的props会得到同样的渲染结果，不会有副作用 无状态组件被鼓励在大型项目中尽可能以简单的写法来分割原本庞大的组件，未来React也会这种面向无状态组件在譬如无意义的检查和内存分配领域进行一系列优化，所以只要有可能，尽量使用无状态组件。 React.createClassReact.createClass是react刚开始推荐的创建组件的方式，这是ES5的原生的JavaScript来实现的React组件。 与无状态组件相比，React.createClass和后面要描述的React.Component都是创建有状态的组件，这些组件是要被实例化的，并且可以访问组件的生命周期方法。但是随着React的发展，React.createClass形式自身的问题暴露出来： React.createClass会自绑定函数方法（不像React.Component只绑定需要关心的函数）导致不必要的性能开销，增加代码过时的可能性。 React.createClass的mixins不够自然、直观；React.Component形式非常适合高阶组件（Higher Order Components–HOC）,它以更直观的形式展示了比mixins更强大的功能，并且HOC是纯净的JavaScript，不用担心他们会被废弃。 React.createClass与React.Component区别 函数this自绑定 React.createClass创建的组件，其每一个成员函数的this都有React自动绑定，任何时候使用，直接使用this.method即可，函数中的this会被正确设置。React.Component创建的组件，其成员函数不会自动绑定this，需要开发者手动绑定，否则this不能获取当前组件实例对象。当然，React.Component有三种手动绑定方法：可以在构造函数中完成绑定，也可以在调用时使用method.bind(this)来完成绑定，还可以使用arrow function来绑定。拿上例的handleClick函数来说，其绑定可以有： 123456 constructor(props) &#123; super(props); this.handleClick = this.handleClick.bind(this); //构造函数中绑定 &#125;&lt;div onClick=&#123;this.handleClick.bind(this)&#125;&gt;&lt;/div&gt; //使用bind来绑定&lt;div onClick=&#123;()=&gt;this.handleClick()&#125;&gt;&lt;/div&gt; //使用arrow function来绑定 组件属性类型propTypes及其默认props属性defaultProps配置不同 React.createClass在创建组件时，有关组件props的属性类型及组件默认的属性会作为组件实例的属性来配置，其中defaultProps是使用getDefaultProps的方法来获取默认组件属性的. React.Component在创建组件时配置这两个对应信息时，他们是作为组件类的属性，不是组件实例的属性，也就是所谓的类的静态属性来配置的。 组件初始状态state的配置不同React.createClass创建的组件，其状态state是通过getInitialState方法来配置组件相关的状态；React.Component创建的组件，其状态state是在constructor中像初始化组件属性一样声明的。 Mixins的支持不同Mixins(混入)是面向对象编程OOP的一种实现，其作用是为了复用共有的代码，将共有的代码通过抽取为一个对象，然后通过Mixins进该对象来达到代码复用。React.createClass在创建组件时可以使用mixins属性，以数组的形式来混合类的集合。 React.Component这种形式并不支持Mixins，至今React团队还没有给出一个该形式下的官方解决方案；但是React开发者社区提供一个全新的方式来取代Mixins,那就是Higher-Order Components。 如何选择哪种方式创建组件由于React团队已经声明React.createClass最终会被React.Component的类形式所取代。但是在找到Mixins替代方案之前是不会废弃掉React.createClass形式。所以： 能用React.Component创建的组件的就尽量不用React.createClass形式创建组件。 除此之外，创建组件的形式选择还应该根据下面来决定： 只要有可能，尽量使用无状态组件创建形式。 否则（如需要state、生命周期方法、ref等），使用React.Component这种es6形式创建组件.]]></content>
  </entry>
  <entry>
    <title><![CDATA[padStart 和 padEnd]]></title>
    <url>%2Fhexo%2F2018%2F07%2F25%2FpadStart%2F</url>
    <content type="text"><![CDATA[padStart 和 padEnd可以在字符串的前后面进行字符补全。 padStart语法如下：1str.padStart(targetLength [, padString]) 其中： targetLength （可选） targetLength指目标字符串长度。 根据测试，targetLength参数缺省也不会报错，原本的字符串原封不动返回，不过代码没有任何意义，因此，基本上没有使用的理由。targetLength参数的类型可以是数值类型或者弱数值类型。在JavaScript中，1 == ‘1’，1是数值，’1’虽然本质上是字符串，但也可以看成是弱数值。在padStart()方法中，数值类型或者弱数值类型都是可以。例如： 1'zhangxinxu'.padStart('5'); 因此，我们实际使用的时候，没必要对targetLength参数进行强制的类型转换。最后，如果targetLength设置的长度比字符串本身还要小，则原本的字符串原封不动返回，例如： 1'zhangxinxu'.padStart(5);// 结果还是'zhangxinxu' padString （可选） padString表示用来补全长度的字符串。然而，虽然语义上是字符串，但是根据我的测试，任意类型的值都是可以的。无论是Chrome浏览器还是Firefox浏览器，都会尝试将这个参数转换成字符串进行补全。例 如下面几个例子： 12345678'zhangxinxu'.padStart(15, false);// 结果是'falsezhangxinxu''zhangxinxu'.padStart(15, null);// 结果是'nullnzhangxinxu''zhangxinxu'.padStart(15, []);// 结果是'zhangxinxu'，因为[]转换成字符串是空字符串'zhangxinxu'.padStart(15, &#123;&#125;);// 结果是'[objezhangxinxu'，只显示了'[object Object]'前5个字符 padString参数默认值是普通空格’ ‘（U+0020），也就是敲Space空格键出现的空格。 从上面几个案例可以看出，如果补全字符串长度不足，则不断循环补全；如果长度超出，则从左侧开始依次补全，没有补到的字符串直接就忽略。 此方法返回值是补全后的字符串。 回到一开始的日期补’0’功能，有了padStart()方法，我们代码可以简化成下面这一行： 1var month = String(new Date().getMonth() + 1).padStart(2, '0'); // 结果是'07' 兼容性IE14以其已下浏览器都不支持，考虑到现在还是windows 7天下，PC端对外项目还不能直接用；移动端，UC浏览器，QQ浏览器也不支持。但是，也不是不能使用，加一个Polyfill就好了，这个后面会展示。 padEndpadEnd可以在字符串的后面进行字符补全，语法参数等都和padStart类似。 语法： 1str.padEnd(targetLength [, padString]) Polyfill代码以下Polyfill代码取自polyfill项目中的string.polyfill.js，其中使用依赖的repeat()也是ES6新增方法，因此，完成Polyfill代码如下，注释部分我做了简单的翻译，代码部分简化了些许逻辑，同时，修复了一个bug，下面代码红色高亮部分就是修复内容： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// https://github.com/uxitten/polyfill/blob/master/string.polyfill.js// repeat()方法的polyfillif (!String.prototype.repeat) &#123; String.prototype.repeat = function (count) &#123; 'use strict'; if (this == null) &#123; throw new TypeError('can\'t convert ' + this + ' to object'); &#125; var str = '' + this; count = +count; if (count != count) &#123; count = 0; &#125; if (count &lt; 0) &#123; throw new RangeError('repeat count must be non-negative'); &#125; if (count == Infinity) &#123; throw new RangeError('repeat count must be less than infinity'); &#125; count = Math.floor(count); if (str.length == 0 || count == 0) &#123; return ''; &#125; if (str.length * count &gt;= 1 &lt;&lt; 28) &#123; throw new RangeError('repeat count must not overflow maximum string size'); &#125; var rpt = ''; for (; ;) &#123; if ((count &amp; 1) == 1) &#123; rpt += str; &#125; count &gt;&gt;&gt;= 1; if (count == 0) &#123; break; &#125; str += str; &#125; return rpt; &#125;&#125;// padStart()方法的polyfillif (!String.prototype.padStart) &#123; String.prototype.padStart = function (targetLength, padString) &#123; // 截断数字或将非数字转换为0 targetLength = targetLength&gt;&gt;0; padString = String((typeof padString !== 'undefined' ? padString : ' ')); if (this.length &gt; targetLength || padString === '') &#123; return String(this); &#125; targetLength = targetLength-this.length; if (targetLength &gt; padString.length) &#123; // 添加到初始值以确保长度足够 padString += padString.repeat(targetLength / padString.length); &#125; return padString.slice(0, targetLength) + String(this); &#125;;&#125;// padEnd()方法的polyfillif (!String.prototype.padEnd) &#123; String.prototype.padEnd = function (targetLength, padString) &#123; // 转数值或者非数值转换成0 targetLength = targetLength &gt;&gt; 0; padString = String((typeof padString !== 'undefined' ? padString : ' ')); if (this.length &gt; targetLength || padString === '') &#123; return String(this); &#125; targetLength = targetLength - this.length; if (targetLength &gt; padString.length) &#123; // 添加到初始值以确保长度足够 padString += padString.repeat(targetLength / padString.length); &#125; return String(this) + padString.slice(0, targetLength); &#125;;&#125; 以上polyfill代码需要放在调用padStart()/padEnd()方法的代码的前面，只要在合适的位置就这么一粘贴，然后，无论什么版本浏览器浏览器，哪怕IE6，IE8，我们也可以放心使用padStart()或者padEnd()方法了。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>bind</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bind的实现原理]]></title>
    <url>%2Fhexo%2F2018%2F07%2F25%2Fbind%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[bind的实现原理 bind() 方法会创建一个新函数。当这个新函数被调用时，bind() 的第一个参数将作为它运行时的 this，之后的一序列参数将会在传递的实参前传入作为它的参数。(来自于 MDN ) 一个绑定函数也能使用new操作符创建对象：这种行为就像把原函数当成构造器。提供的 this 值被忽略，同时调用时的参数被提供给模拟函数。 参考Blog es5-shim 实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110// ES-5 15.3.4.5// http://es5.github.com/#x15.3.4.5function Empty() &#123;&#125;if (!Function.prototype.bind) &#123; Function.prototype.bind = function bind(that) &#123; // .length is 1 // 1. Let Target be the this value. var target = this; // 2. If IsCallable(Target) is false, throw a TypeError exception. if (typeof target != "function") &#123; throw new TypeError("Function.prototype.bind called on incompatible " + target); &#125; // 3. Let A be a new (possibly empty) internal list of all of the // argument values provided after thisArg (arg1, arg2 etc), in order. // XXX slicedArgs will stand in for "A" if used var args = _Array_slice_.call(arguments, 1); // for normal call // 4. Let F be a new native ECMAScript object. // 11. Set the [[Prototype]] internal property of F to the standard // built-in Function prototype object as specified in 15.3.3.1. // 12. Set the [[Call]] internal property of F as described in // 15.3.4.5.1. // 13. Set the [[Construct]] internal property of F as described in // 15.3.4.5.2. // 14. Set the [[HasInstance]] internal property of F as described in // 15.3.4.5.3. var bound = function () &#123; if (this instanceof bound) &#123; // 15.3.4.5.2 [[Construct]] // When the [[Construct]] internal method of a function object, // F that was created using the bind function is called with a // list of arguments ExtraArgs, the following steps are taken: // 1. Let target be the value of F's [[TargetFunction]] // internal property. // 2. If target has no [[Construct]] internal method, a // TypeError exception is thrown. // 3. Let boundArgs be the value of F's [[BoundArgs]] internal // property. // 4. Let args be a new list containing the same values as the // list boundArgs in the same order followed by the same // values as the list ExtraArgs in the same order. // 5. Return the result of calling the [[Construct]] internal // method of target providing args as the arguments. var result = target.apply( this, args.concat(_Array_slice_.call(arguments)) ); if (Object(result) === result) &#123; return result; &#125; return this; &#125; else &#123; // 15.3.4.5.1 [[Call]] // When the [[Call]] internal method of a function object, F, // which was created using the bind function is called with a // this value and a list of arguments ExtraArgs, the following // steps are taken: // 1. Let boundArgs be the value of F's [[BoundArgs]] internal // property. // 2. Let boundThis be the value of F's [[BoundThis]] internal // property. // 3. Let target be the value of F's [[TargetFunction]] internal // property. // 4. Let args be a new list containing the same values as the // list boundArgs in the same order followed by the same // values as the list ExtraArgs in the same order. // 5. Return the result of calling the [[Call]] internal method // of target providing boundThis as the this value and // providing args as the arguments. // equiv: target.call(this, ...boundArgs, ...args) return target.apply( that, args.concat(_Array_slice_.call(arguments)) ); &#125; &#125;; if (target.prototype) &#123; Empty.prototype = target.prototype; bound.prototype = new Empty(); // Clean up dangling references. Empty.prototype = null; &#125; // XXX bound.length is never writable, so don't even try // // 15. If the [[Class]] internal property of Target is "Function", then // a. Let L be the length property of Target minus the length of A. // b. Set the length own property of F to either 0 or L, whichever is // larger. // 16. Else set the length own property of F to 0. // 17. Set the attributes of the length own property of F to the values // specified in 15.3.5.1. // TODO // 18. Set the [[Extensible]] internal property of F to true. // TODO // 19. Let thrower be the [[ThrowTypeError]] function Object (13.2.3). // 20. Call the [[DefineOwnProperty]] internal method of F with // arguments "caller", PropertyDescriptor &#123;[[Get]]: thrower, [[Set]]: // thrower, [[Enumerable]]: false, [[Configurable]]: false&#125;, and // false. // 21. Call the [[DefineOwnProperty]] internal method of F with // arguments "arguments", PropertyDescriptor &#123;[[Get]]: thrower, // [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: false&#125;, // and false. // TODO // NOTE Function objects created using Function.prototype.bind do not // have a prototype property or the [[Code]], [[FormalParameters]], and // [[Scope]] internal properties. // XXX can't delete prototype in pure-js. // 22. Return F. return bound; &#125;;&#125;]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>bind</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP协议]]></title>
    <url>%2Fhexo%2F2018%2F07%2F07%2Ftcp%2F</url>
    <content type="text"><![CDATA[TCP（Transmission Control Protocol，传输控制协议）TCP是一种面向连接（连接导向）的、可靠的基于字节流的传输层通信协议。TCP将用户数据打包成报文段，它发送后启动一个定时器，另一端收到的数据进行确认、对失序的数据重新排序、丢弃重复数据。TCP的特点有： TCP是面向连接的运输层协议 每一条TCP连接只能有两个端点，每一条TCP连接只能是点对点的 TCP提供可靠交付的服务 TCP提供全双工通信。数据在两个方向上独立的进行传输。因此，连接的每一端必须保持每个方向上的传输数据序号。 面向字节流。面向字节流的含义：虽然应用程序和TCP交互是一次一个数据块，但TCP把应用程序交下来的数据仅仅是一连串的无结构的字节流。 TCP头格式 （1）Source Port（源端口号）：数据发起者的端口号，16bit。（2）Destination Port（目的端口号）：数据接收者的端口号，16bit。（3）Sequence Number（顺序号码，Seq）：用于在数据通信中解决网络包乱序（reordering）问题，以保证应用层接收到的数据不会因为网络上的传输问题而乱序（TCP会用这个顺序号码来拼接数据），32bit。（4）Acknowledgment Number（确认号码，ack）：是数据接收方期望收到发送方在下一个报文段的顺序号码（Seq），因此确认号码应当是上次已成功收到顺序号码（Seq）加1，32bit。（5）Offset（TCP报文头长度)：用于存储报文头中有多少个32bit(上图的一行)，存储长度为4bit，最大可表示（2^3+2^2+2^1+1）_32bit=60bytes的报文头。最小取值5，5_32bit=20bytes。（6）Reserved（保留）：6bit, 均为0（7）TCP Flags（TCP标志位）每个长度均为1bit CWR：压缩，TCP Flags值0x80。 ECE：拥塞，0x40。 URG：紧急，0x20。当URG=1时，表示报文段中有紧急数据，应尽快传送。 ACK：确认，0x10。当ACK = 1时，代表这是一个确认的TCP包，取值0则不是确认包。 PSH：推送，0x08。当发送端PSH=1时，接收端尽快的交付给应用进程。 RST：复位，0x04。当RST=1时，表明TCP连接中出现严重差错，必须释放连接，再重新建立连接。 SYN：同步，0x02。在建立连接是用来同步序号。SYN=1， ACK=0表示一个连接请求报文段。SYN=1，ACK=1表示同意建立连接。 FIN：终止，0x01。当FIN=1时，表明此报文段的发送端的数据已经发送完毕，并要求释放传输连接。 （8）窗口：用来控制对方发送的数据量，通知发放已确定的发送窗口上限。（9）检验和：该字段检验的范围包括头部和数据这两部分。由发端计算和存储，并由收端进行验证。（10）紧急指针：紧急指针在URG=1时才有效，它指出本报文段中的紧急数据的字节数。（11）TCP选项：长度可变，最长可达40字节 备注：ISN（Inital Sequence Number）：初始化Sequence Number，发生在建立连接时。 TCP协议中的三次握手和四次挥手 特别注意 Seq：是发送方当前报文的顺序号码。ack：是发送方期望对方在下次返回报文中给回的Seq。 建立连接需要三次握手 第一次握手：客户端向服务端发送连接请求包，标志位SYN（同步序号）置为1，顺序号码为X=0。 第二次握手：服务端收到客户端发过来报文，由SYN=1知道客户端要求建立联机，则为这次连接分配资源。并向客户端发送一个SYN和ACK都置为1的TCP报文，设置初始顺序号码Y=0，将确认序号(ack)设置为上一次客户端发送过来的顺序号(Seq)加1，即X+1 = 0+1=1。 第三次握手：客户端收到服务端发来的包后检查确认号码(ack)是否正确，即第一次发送的Seq加1（X+1=1）。以及标志位ACK是否为1。若正确，服务端再次发送确认包，ACK标志位为1，SYN标志位为0。确认号码(ack)=Y+1=0+1=1，发送顺序号码(Seq)为X+1=1。Server收到后确认号码值与ACK=1则连接建立成功，可以传送数据了。 断开连接需要四次挥手提醒：中断连接端可以是Client端，也可以是Server端。只要将下面两角色互换即可。 第一次挥手：客户端给服务端发送FIN报文，用来关闭客户端到服务端的数据传送。将标志位FIN和ACK置为1，顺序号码为X=1，确认号码为Z=1。意思是说”我Client端没有数据要发给你了，但是如果你还有数据没有发送完成，则不必急着关闭Socket，可以继续发送数据。所以你先发送ACK过来。” 第二次挥手：服务端收到FIN后，发回一个ACK(标志位ACK=1),确认号码为收到的顺序号码加1，即X=X+1=2。顺序号码为收到的确认号码=Z。意思是说“你的FIN请求我收到了，但是我还没准备好，请继续你等我的消息” 这个时候客户端就进入FIN_WAIT状态，继续等待服务端的FIN报文。 第三次挥手：当服务端确定数据已发送完成，则向客户端发送FIN报文，关闭与客户端的连接。标志位FIN和ACK置为1，顺序号码为Y=1，确认号码为X=2。意思是告诉Client端“好了，我这边数据发完了，准备好关闭连接了。” 第四次挥手：客户端收到服务器发送的FIN之后，发回ACK确认(标志位ACK=1),确认号码为收到的顺序号码加1，即Y+1=2。顺序号码为收到的确认号码X=2。意思是“我Client端知道可以关闭连接了，但是我还是不相信网络，怕 Server端不知道要关闭，所以发送ACK后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，我Client端也可以关闭连接了。“（在TIME_WAIT状态中，如果TCP client端最后一次发送的ACK丢失了，它将重新发送。TIME_WAIT状态中所需要的时间是依赖于实现方法的。典型的值为30秒、1分钟和2分钟。等待之后连接正式关闭，并且所有的资源(包括端口号)都被释放。） 为什么关闭的时候却是四次挥（握）手？因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。 相关资料Hypertext Transfer Protocol – HTTP/1.1 TCP/IP Reference TCP 的那些事儿（上） TCP协议中的三次握手和四次挥手(图解)]]></content>
      <categories>
        <category>Http</category>
      </categories>
      <tags>
        <tag>-TCP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于正则的一些记录]]></title>
    <url>%2Fhexo%2F2018%2F07%2F06%2FregExp%2F</url>
    <content type="text"><![CDATA[关于正则的一些记录 1. 字符串选择The dog chased the cat中单词 the，我们可以使用正则表达式: /the/gi,我们可以把这个正则表达式分成几段： / 是这个正则表达式的头部 the 是我们想要匹配的模式 / 是这个正则表达式的尾部 g 代表着 global(全局)，意味着返回所有的匹配而不仅仅是第一个。 i 代表着忽略大小写，意思是当我们寻找匹配的字符串的时候忽略掉字母的大小写。 2. 数字选择在JavaScript中, 数字选择器类似于: /\d/g。 在选择器后面添加一个加号标记(+)，例如：/\d+/g，它允许这个正则表达式匹配一个或更多数字。 例如： 1234567var testString = &quot;There are 34 cats but 4 dogs.&quot;;var expression = /\d+/g; result:[ &apos;34&apos;, &apos;4&apos; ]var expression = /\d/g; result:[ &apos;3&apos;, &apos;4&apos;, &apos;4&apos; ] 尾部的g是’global’的简写，意思是允许这个正则表达式 找到所有的匹配而不是仅仅找到第一个匹配。 123456789var testString = &quot;There are 3 cats but 4 dogs.&quot;;var expression = /\d+/g; // Change this linevar digitCount = testString.match(expression);//.length;console.log(digitCount)[ &apos;3&apos;, &apos;4&apos; ][Finished in 0.1s] 3. 选择反转你可以用正则表达式选择器的大写版本 来转化任何匹配。举个例子：\s 匹配任何空白字符，\S 匹配任何非空白字符。 4. 子串现在有如下一串字符串： “asdfkjasldjkf”shiner”df 需求： 需要提取出shiner子字符串。 命令如下： echo “asdfkjasldjkf\”shiner\”df” | sed ‘s/(.)“(.)“(.*)/\2/g’ shiner 命令解释 s： 表示替换命令 (.)“ : 表示第一个引号前的内容 “(.)“：表示两引号之间的内容 )”(.*)：表示引号后的内容 \2: 表示第二对括号里面的内容 括号里的表达式匹配的内容，可以用\1，\2等进行引用，第n个括号对内的内容，就用\n引用。 这个命令的意思是：用\2代表的第二个括号的内容（shiner）去替换整个字符串，这样就得到了我们所需要的子字符串了。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>-RegExp -JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[各种排序汇总]]></title>
    <url>%2Fhexo%2F2018%2F07%2F06%2Fsort%2F</url>
    <content type="text"><![CDATA[各种排序汇总 以下都是js的简单实现。 排序的稳定性假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，ri=rj，且ri在rj之前，而在排序后的序列中，ri仍在rj之前，则称这种排序算法是稳定的；否则称为不稳定的。 选择排序、快速排序、希尔排序、堆排序不是稳定的排序算法；而冒泡排序、插入排序、归并排序和基数排序是稳定的排序算法。 1.直接插入基本思想：前i个数是已经排好的数，然后把第i+1个数插入其中。 123456789function insertSort(arr)&#123; let len = arr.length; for(let i = 1; i &lt; len; i++)&#123; for(let j = i; j &gt; 0; j--)&#123; if(arr[j] &lt; arr[j-1]) swap(arr,j,j-1); else break; &#125; &#125;&#125; 2.快速排序基本思想：挑选一个元素，称为 “基准”（pivot），重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边），这个称为分区（partition）操作。然后对两个分区进行递归。 123456789101112131415function quickSort(arr)&#123; partition(arr,0,arr.length-1);&#125;function partition(arr,lo,hi)&#123; if(lo &gt;= hi) return; let i = lo,j = hi; while(i &lt; j)&#123; while(j&gt;i &amp;&amp;arr[j] &gt;= arr[i])j--; swap(arr,i,j) while(j&gt;i &amp;&amp; arr[i] &lt;= arr[j])i++; swap(arr,i,j); &#125; partition(arr,lo,j-1); partition(arr,j+1,hi);&#125; 2.1选择基准方法(1)：固定位置思想：取序列的第一个或最后一个元素作为基准 方法(2)：随机选取基准引入的原因：在待排序列是部分有序时，固定选取枢轴使快排效率底下，要缓解这种情况，就引入了随机选取枢轴具体操作：选择基准，把枢轴位置的元素和low位置元素互换，此时可以和普通的快排一样调用划分函数 方法(3)：三数取中（median-of-three）引入的原因：虽然随机选取枢轴时，减少出现不好分割的几率，但是还是最坏情况下还是O(n^2），要缓解这种情况，就引入了三数取中选取枢轴 2.2优化优化1、当待排序序列的长度分割到一定大小后，使用插入排序。原因：对于很小和部分有序的数组，快排不如插排好。当待排序序列的长度分割到一定大小后，继续分割的效率比插入排序要差，此时可以使用插排而不是快排 截止范围：待排序序列长度N = 10，虽然在5~20之间任一截止范围都有可能产生类似的结果，这种做法也避免了一些有害的退化情形。摘自《数据结构与算法分析》Mark Allen Weiness 著 优化2、在一次分割结束后，可以把与Key相等的元素聚在一起，继续下次分割时，不用再对与key相等元素分割：(对有很多重复元素的数组排序提升很大)具体过程：在处理过程中，会有两个步骤 第一步，在划分过程中，把与key相等元素放入数组的两端 第二步，划分结束后，把与key相等的元素移到枢轴周围 3.选择排序思路：每次从剩余 n-i 个数中找出最小的，放到第i位上。不稳定，比如 [5,5,3] 5和3会交换，导致原本在前面的5到了后面。 123456789function selectSort(arr)&#123; for(let i = 0; i &lt; arr.length; i++)&#123; let min = i; for(let j = i+1; j &lt; arr.length; j++)&#123; if(arr[j] &lt; arr[min]) min = j; &#125; swap(arr,min,i); &#125;&#125; 3.1优化二元选择排序：简单选择排序，每趟循环只能确定一个元素排序后的定位。我们可以考虑改进为每趟循环确定两个元素（当前趟最大和最小记录）的位置,从而减少排序所需的循环次数。 4.归并排序思路：每次把两个排好序的数组归并在一起。 123456789101112131415161718function mergeSort(arr)&#123; if(arr.length === 1) return arr; let mid = ~~(arr.length/2); let left = arr.slice(0,mid),right = arr.slice(mid); return merge(mergeSort(left),mergeSort(right));&#125;function merge(a,b)&#123; let res = [], i = 0, j = 0; while(i &lt; a.length &amp;&amp; j &lt; b.length) &#123; if(a[i] &gt; b[j]) res.push(b[j++]); else res.push(a[i++]); &#125; if(i &lt; a.length) res = [...res,...a.slice(i)]; if(j &lt; b.length) res = [...res,...b.slice(j)]; return res;&#125; 5.希尔排序基于插入排序的优化排序，按照不同步长对元素进行插入排序，当刚开始元素很无序的时候，步长最大，所以插入排序的元素个数很少，速度很快；当元素基本有序了，步长很小，插入排序对于有序的序列效率很高(排好序的数组，插入排序O(N)复杂度)。希尔排序是不稳定的。 1234567891011121314function shellSort(arr)&#123; let d = ~~ (arr.length/2); while(d&gt;=1)&#123; for(let i = 0; i &lt; d; i++)&#123; for(let j = i+d; j &lt; arr.length; j += d)&#123; for(let k = j; k &gt;= d; k-=d)&#123; if(arr[k] &lt; arr[k-d]) swap(arr,k,k-d); else break; &#125; &#125; &#125; d = ~~(d/2); &#125;&#125; 6.冒泡排序思路：两两比较，大的上浮（或者小的），一趟下来最大的数浮到了顶部。如果一次交换都没发生，说明排序完成。 123456789101112function bubbleSort(arr)&#123; for(let i = arr.length-1; i&gt;0; i--)&#123; let count = 0; for(let j = 0; j &lt; i; j++)&#123; if(arr[j+1] &lt; arr[j]) &#123; swap(arr,j,j+1); // &gt;还是&lt;可以控制浮动方向 count++; &#125; &#125; if(count === 0) break; &#125;&#125; 7.堆排序 思路：堆排序是不稳定的，在性能上稳定O(nlogN),意味着不管是有序无序都会运行这么久，空间O(1)。 先将初始文件R[1..n]建成一个大根堆，此堆为初始的无序区 再将关键字最大的记录R[1]（即堆顶）和无序区的最后一个记录R[n]交换，由此得到新的无序区R[1..n-1]和有序区R[n]，且满足R[1..n-1].keys≤R[n].key 由于交换后新的根R[1]可能违反堆性质，故应将当前无序区R[1..n-1]调整为堆。然后再次将R[1..n-1]中关键字最大的记录R[1]和该区间的最后一个记录R[n-1]交换，由此得到新的无序区R[1..n-2]和有序区R[n-1..n]，且仍满足关系R[1..n-2].keys≤R[n-1..n].keys，同样要将R[1..n-2]调整为堆。 12345678910111213141516171819202122232425262728function heapSort(arr)&#123; let i = arr.length /2; for(;i&gt;=0;--i)&#123; fix(arr,i,arr.length); &#125; for(i = arr.length-1; i&gt;0; i--)&#123; swap(arr,0,i); fix(arr,0,i); &#125;&#125;/** * 调整堆 * @param &#123;Array&#125; arr * @param &#123;number&#125; i : 要调整的元素位置 * @param &#123;number&#125; length ： 调整范围 */function fix(arr,i,length)&#123; let child ; for(; 2*i+1 &lt; length; i=child)&#123; child = 2*i+1; if(child &lt; length-1 &amp;&amp; arr[child+1]&gt;arr[child])child++; if(arr[i]&lt;arr[child])&#123; swap(arr,i,child); &#125; else break; &#125;&#125; 8.堆排序、快速排序、堆排序性能比较对长度为1000的随机数组，排序100个的时间：希尔：65ms 快速：5ms 堆排序：7ms 归并：114ms (归并在实现过程中数组的切分可能造成了性能损耗) 对排好序的数组进行排序：堆排序:7ms 快速：78ms (此时是快速的最差情况O(N^2)) 希尔：36ms 归并：106ms 测试代码： 123456789101112131415161718192021function random()&#123; return ~~(Math.random()*10000);&#125;function randomArr(length)&#123; let res = [], i =0; while(i&lt;length)&#123; res.push(random()); i++; &#125; return res;&#125;let time = 0;for(let i = 0; i&lt;100; i++)&#123; let arr = randomArr(1000); //quickSort(arr); //先用快排排序，测试排好序的数组排序 let start = new Date(); quickSort(arr); let end = new Date(); time += end - start;&#125;console.log(time) 参考排序算法稳定性 视觉直观感受 三种快速排序以及快速排序的优化]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>-sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React渲染]]></title>
    <url>%2Fhexo%2F2018%2F07%2F01%2FReact-render%2F</url>
    <content type="text"><![CDATA[##渲染 合并操作你调用 component 的 setState 方法的时候, React 将其标记为 dirty。到每一个事件循环结束, React 检查所有标记 dirty 的 component 重新绘制。 这里的”合并操作”是说, 在一个事件循环当中, DOM 只会被更新一次.这个特性是构建高性能应用的关键, 而且用通常的 JavaScript 代码难以实现。 而在 React 应用里, 你默认就能实现。 子树渲染调用 setState 方法时, component 会重新构建包括子节点的 virtual DOM。 如果你在根节点调用 setState, 整个 React 的应用都会被重新渲染.所有的 component, 即便没有更新, 都会调用他们的 render 方法.这个听起来可怕, 性能像是很低, 但实际上我们不会触碰真实的 DOM, 运行起来没那样的问题。 首先, 我们讨论的是展示用户界面. 因为屏幕空间有限, 通常你需要一次渲染成百上千条指令.JavaScript 对于能处理的整个界面, 在业务逻辑上已经足够快了。 另一点, 在写 React 代码时, 每当有数据更新, 你不是都调用根节点的 setState。 你会在需要接收对应更新的 component 上调用, 或者在上面的几个 component。 你很少要一直到根节点上. 就是说界面更新只出现在用户产生交互的局部。 选择性子树渲染最后, 你还有可能去掉一些子树的重新渲染.如果你在 component 上实现以下方法的话: 1boolean shouldComponentUpdate(object nextProps, object nextState) 根据 component 的前一个和下一个 props/state,你可以告诉 React 这个 component 没有更新, 也不需要重新绘制。实现得好的话, 可以带来巨大的性能提升。 要用这个方法, 你要能够对 JavaScript Object 进行比对。这件有很多细节的因素, 比如对比应该是深度的还是浅层的,如果要深的, 我们是用不可变数据结构, 还是进行深度拷贝… 而且你要注意, 这个函数每次都会被调用, 所以你要确保运行起来花的时间更少,比 React 的做法时间少, 还有比计算 component 需要的时间少,即便重新绘制并不是必要的。 总结React 消耗性能的模型很简单, 很好理解: 每次调用 setState 会重新计算整个子树。 如果你想要提高性能, 尽量少调用 setState,还有用 shouldComponentUpdate 减少大的子树的重新计算。]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>-React -Render</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React diff 算法]]></title>
    <url>%2Fhexo%2F2018%2F07%2F01%2FReact-diff%2F</url>
    <content type="text"><![CDATA[React diff 算法React 中最值得称道的部分莫过于 Virtual DOM 与 diff 的完美结合，特别是其高效的 diff 算法，这让我们可以无需担心性能问题而”毫无顾忌”的随时“刷新”整个页面，由虚拟DOM来确保只对界面上真正变化的部分进行实际的DOM操作。 什么是DOM Diff算法Web界面由DOM树来构成，当其中某一部分发生变化时，其实就是对应的某个DOM节点发生了变化。在React中，构建UI界面的思路是由当前状态决定界面。前后两个状态就对应两套界面，然后由React来比较两个界面的区别，这就需要对DOM树进行Diff算法分析。 即给定任意两棵树，找到最少的转换步骤。但是标准的的Diff算法复杂度需要O(n^3)，这显然无法满足性能要求。要达到每次界面都可以整体刷新界面的目的，势必需要对算法进行优化。这看上去非常有难度，然而Facebook工程师却做到了，他们结合Web界面的特点做出了两个简单的假设，使得Diff算法复杂度直接降低到O(n) 两个相同组件产生类似的DOM结构，不同的组件产生不同的DOM结构； 对于同一层次的一组子节点，它们可以通过唯一的id进行区分。 Dom节点树 diffReact的整个内容其实就是一棵Virtual Node组成的Tree。 任何时间, 你描述的是你的 UI 看起来是什么样子。 需要特别注意, render 执行的结果得到的不是真正的 DOM 节点。 结果仅仅是轻量级的 JavaScript 对象, 我们称之为 virtual DOM。 按照层级找到两棵任意的树之间最小的修改是一个复杂度为 O(n^3) 的问题.React 用了一种简单但是强大的技巧, 达到了接近 O(n) 的复杂度. React 仅仅是尝试把树按照层级分解. 这彻底简化了复杂度,而且也不会失去很多, 因为 Web 应用很少有 component 移动到树的另一个层级去。它们大部分只是在相邻的子节点之间移动。 React只会对相同颜色方框内的DOM节点进行比较，即同一个父节点下的所有子节点。 当发现节点已经不存在，则该节点及其子节点会被完全删除掉，不会用于进一步的比较。这样只需要对树进行一次遍历，便能完成整个DOM树的比较。 由此可发现，当出现节点跨层级移动时，并不会出现想象中的移动操作，而是以 A 为根节点的树被整个重新创建，这是一种影响 React 性能的操作，因此 React 官方建议不要进行 DOM 节点跨层级的操作。 注意：在开发组件时，保持稳定的 DOM 结构会有助于性能的提升。例如，可以通过 CSS 隐藏或显示节点，而不是真的移除或添加 DOM 节点。 ComponentReact 是基于组件构建应用的，一个组件可以看做virtual DOM tree中的一棵子树。 如果是同一类型（相同 class）的组件，按照原策略继续比较 virtual DOM tree。 如果不是，则将该组件判断为 dirty component，从而替换整个组件下的所有子节点。 如图，当 component D 改变为 component G 时，即使这两个 component 结构相似，一旦 React 判断 D 和 G 是不同类型的组件，就不会比较二者的结构，而是直接删除 component D，重新创建 component G 以及其子节点。 虽然当两个 component 是不同类型但结构相似时，React diff 会影响性能，但正如 React 官方博客所言：不同类型的 component 是很少存在相似 DOM tree 的机会，因此这种极端因素很难在实现开发过程中造成重大影响的。 列表假设我们有个 component, 一个循环渲染了 5 个 component,随后又在列表中间插入一个新的 component.只知道这些信息, 要弄清两个 component 的列表怎么对应很难. 默认情况下, React 会将前一个列表第一个 component 和后一个第一个关联起来, 后面也是。你可以写一个 key 属性帮助 React 来处理它们之间的对应关系。实际中, 在子元素中找到唯一的 key 通常很容易。 列表节点的操作通常包括添加、删除和排序。例如下图，我们需要往B和C直接插入节点F。在React中，我们只告诉React新的界面应该是A-B-F-C-D-E，由Diff算法完成更新界面。 这时如果每个节点都没有唯一的标识，React无法识别每一个节点，那么更新过程会很低效，即，将C更新成F，D更新成C，E更新成D，最后再插入一个E节点。效果如下图所示： 可以看到，React会逐个对节点进行更新，转换到目标节点。而最后插入新的节点E，涉及到的DOM操作非常多。而如果给每个节点唯一的标识（key），那么React能够找到正确的位置去插入新的节点，入下图所示： 节点的比较在React中比较两个虚拟DOM节点,分为两种情况： 节点类型不同 (类似组件比较）当在树中的同一位置前后输出了不同类型的节点，React直接删除前面的节点，然后创建并插入新的节点。假设我们在树的同一位置前后两次输出不同类型的节点。 节点类型相同，但是属性不同。React会对属性进行重设从而实现节点的转换。 123456789var MyComponent = React.createClass(&#123; render: function() &#123; if (this.props.first) &#123; return &lt;div className="first"&gt;&lt;span&gt;A Span&lt;/span&gt;&lt;/div&gt;; &#125; else &#123; return &lt;div className="second"&gt;&lt;p&gt;A Paragraph&lt;/p&gt;&lt;/div&gt;; &#125; &#125;&#125;); 比如, 当我们挂载了 &lt;MyComponent first={true} /&gt;, 然后用 &lt;MyComponent first={false} /&gt; 替换, 然后又取消挂载,这样一个过程的 DOM 的指令是这样的: 从没有到第一步创建节点: &lt;div className=&quot;first&quot;&gt;&lt;span&gt;A Span&lt;/span&gt;&lt;/div&gt; 第一步到第二步替换属性: className=&quot;first&quot; 到 className=&quot;second&quot;替换节点: &lt;span&gt;A Span&lt;/span&gt;到 &lt;p&gt;A Paragraph&lt;/p&gt; 第二步到没有删除节点:&lt;div className=&quot;second&quot;&gt;&lt;p&gt;A Paragraph&lt;/p&gt;&lt;/div&gt; 总结 分层求异,将复杂度从O(n^3)降低，接近O(n) 相同类型的组件，进行节点比较；不同类型，直接删去旧组件，创建新组建。 相同类型节点，更新属性；不同类型，删去旧节点，创建新节点。 设置每一层中唯一key，帮助React处理组件之间的对应关系。 建议 在开发组件时，保持稳定的 DOM 结构会有助于性能的提升； 在开发过程中，尽量减少类似将最后一个节点移动到列表首部的操作，当节点数量过大或更新操作过于频繁时，在一定程度上会影响 React 的渲染性能。 看完这些，可以看看：React渲染 参考React’s diff algorithmReact 源码剖析系列 － 不可思议的 react diff深入浅出React（四）：虚拟DOM Diff算法解析]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>-React -diff</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PureRenderMixin 与 PureComponent]]></title>
    <url>%2Fhexo%2F2018%2F06%2F30%2Freact-purecomponent%2F</url>
    <content type="text"><![CDATA[PureRenderMixin 与 PureComponent为了提高React组件渲染性能，React 针对组件的 shouldComponentUpdate 方法进行了封装处理，我们不需要在每个组件里面手动编写 shouldComponentUpdate。 PureRenderMixinReact在之前版本提供了 PureRenderMixin 的mixin形式，其用法如下： 1234567// react官方demoimport PureRenderMixin from 'react-addons-pure-render-mixin';class FooComponent extends React.Component &#123; constructor(props) &#123; super(props); this.shouldComponentUpdate = PureRenderMixin.shouldComponentUpdate.bind(this); &#125; 其原理就是重写了 shouldComponentUpdate 方法。 PureComponentReact 15.3.0 新增了一个 PureComponent 类，以 ES2015 class 的方式方便地定义纯组件 (pure component)，用于取代之前的 PureRenderMixin。 这个类的用法很简单，如果你有些组件是纯组件，那么把继承类从 Component 换成 PureComponent 即可。当组件更新时，如果组件的 props 和 state 都没发生改变，render 方法就不会触发，省去 Virtual DOM 的生成和比对过程，达到提升性能的目的。 原理当组件更新时，如果组件的 props 和 state 都没发生改变， render 方法就不会触发，省去 Virtual DOM 的生成和比对过程，达到提升性能的目的。具体就是 React 自动帮我们做了一层浅比较： 1234if (this._compositeType === CompositeTypes.PureClass) &#123; shouldUpdate = !shallowEqual(prevProps, nextProps) || !shallowEqual(inst.state, nextState);&#125; 而 shallowEqual 又做了什么呢？会比较 Object.keys(state | props) 的长度是否一致，每一个 key 是否两者都有，并且是否是一个引用，也就是只比较了第一层的值，确实很浅，所以深层的嵌套数据是对比不出来的。 这里要注意的是：PureRenderMixin、PureComponent 内进行的仅仅是浅比较对象(shallowCompare)。如果对象包含了复杂的数据结构，深层次的差异可能会产生误判。比如，如果我们的state变为： 123456state = &#123; value: &#123; foo: 'bar' &#125;&#125;// 每次更改value值的时候进行：this.setState(&#123; value: newValue &#125;); 此时直接通过值的比较是行不通的，因为对象的引用关系，导致在子组件里面接受到的 this.props.value 与 nextProps.value 永远都是相等的。 Eg2： 123456789101112131415161718class App extends PureComponent &#123; state = &#123; items: [1, 2, 3] &#125; handleClick = () =&gt; &#123; const &#123; items &#125; = this.state; items.pop(); this.setState(&#123; items &#125;); &#125; render() &#123; return (&lt;div&gt; &lt;ul&gt; &#123;this.state.items.map(i =&gt; &lt;li key=&#123;i&#125;&gt;&#123;i&#125;&lt;/li&gt;)&#125; &lt;/ul&gt; &lt;button onClick=&#123;this.handleClick&#125;&gt;delete&lt;/button&gt; &lt;/div&gt;) &#125;&#125; 会发现，无论怎么点 delete 按钮， li 都不会变少，因为 items 用的是一个引用， shallowEqual 的结果为 true 。改正： 12345handleClick = () =&gt; &#123; const &#123; items &#125; = this.state; items.pop(); this.setState(&#123; items: [].concat(items) &#125;);&#125; 这样每次改变都会产生一个新的数组，也就可以 render 了。这里有一个矛盾的地方，如果没有 items.pop(); 操作，每次 items 数据并没有变，但还是 render 了，数据都不变，你 setState 干嘛？ 这里的解决方案主要有： 深比较： 原理与深拷贝类似，比较耗时，不推荐 immutable.js：FaceBook官方提出的不可变数据解决方案，主要解决了复杂数据在deepClone和对比过程中性能损耗 使用1234567import React, &#123; PureComponent &#125; from 'react'class Example extends PureComponent &#123; render() &#123; // ... &#125;&#125; 兼容旧版本1234import React &#123; PureComponent, Component &#125; from 'react';class Foo extends (PureComponent || Component) &#123; //...&#125; 与 shouldComponentUpdate 共存如果 PureComponent 里有 shouldComponentUpdate 函数的话，直接使用 shouldComponentUpdate 的结果作为是否更新的依据，没有 shouldComponentUpdate 函数的话，才会去判断是不是 PureComponent ，是的话再去做 shallowEqual 浅比较。 1234567891011// 这个变量用来控制组件是否需要更新var shouldUpdate = true;// inst 是组件实例if (inst.shouldComponentUpdate) &#123; shouldUpdate = inst.shouldComponentUpdate(nextProps, nextState, nextContext);&#125; else &#123; if (this._compositeType === CompositeType.PureClass) &#123; shouldUpdate = !shallowEqual(prevProps, nextProps) || !shallowEqual(inst.state, nextState); &#125;&#125; 参考React PureComponent 使用指南]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>-React -PureComponent</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React中props和state的区别]]></title>
    <url>%2Fhexo%2F2018%2F06%2F29%2FReact-props-state%2F</url>
    <content type="text"><![CDATA[React中props和state的区别state的作用state是React中组件的一个对象.React把用户界面当做是状态机,想象它有不同的状态然后渲染这些状态,可以轻松让用户界面与数据保持一致. React中,更新组件的state,会导致重新渲染用户界面(不要操作DOM).简单来说,就是用户界面会随着state变化而变化. state工作原理常用的通知React数据变化的方法是调用setState(data,callback).这个方法会合并data到this.state,并重新渲染组件.渲染完成后,调用可选的callback回调.大部分情况不需要提供callback,因为React会负责吧界面更新到最新状态. 那些组件应该有state?大部分组件的工作应该是从props里取数据并渲染出来.但是,有时需要对用户输入,服务器请求或者时间变化等作出响应,这时才需要state. 组件应该尽可能的无状态化,这样能隔离state,把它放到最合理的地方(Redux做的就是这个事情?),也能减少冗余并易于解释程序运作过程. 常用的模式就是创建多个只负责渲染数据的无状态(stateless)组件,在他们的上层创建一个有状态(stateful)组件并把它的状态通过props 传给子级.有状态的组件封装了所有的用户交互逻辑,而这些无状态组件只负责声明式地渲染数据. 哪些应该作为state?state应该包括那些可能被组件的事件处理器改变并触发用户界面更新的数据。这中数据一般很小且能被JSON序列化。 当创建一个状态化的组件的时候,应该保持数据的精简,然后存入this.state。 在render()中在根据state来计算需要的其他数据.因为如果在state里添加冗余数据或计算所得数据,经常需要手动保持数据同步。 那些不应该作为state?this.state应该仅包括能表示用户界面状态所需要的最少数据.因此,不应该包括: 计算所得数据; React组件:在render()里使用props和state来创建它; 基于props的重复数据:尽可能保持用props来做作为唯一的数据来源。把props保存到state中的有效的场景是需要知道它以前的值得时候,因为未来的props可能会变化。 ###props 1.props的作用 组件中的props是一种父级向子级传递数据的方式。 2.复合组件 123456789101112131415161718192021222324252627282930313233var Avatar = React.createClass(&#123; render: function() &#123; return ( &lt;div&gt; &lt;ProfilePic username=&#123;this.props.username&#125; /&gt; &lt;ProfileLink username=&#123;this.props.username&#125; /&gt; &lt;/div&gt; ); &#125;&#125;);var ProfilePic = React.createClass(&#123; render: function() &#123; return ( &lt;img src=&#123;&apos;http://graph.facebook.com/&apos; + this.props.username + &apos;/picture&apos;&#125; /&gt; ); &#125;&#125;);var ProfileLink = React.createClass(&#123; render: function() &#123; return ( &lt;a href=&#123;&apos;http://www.facebook.com/&apos; + this.props.username&#125;&gt; &#123;this.props.username&#125; &lt;/a&gt; ); &#125;&#125;);React.render( &lt;Avatar username=&quot;pwh&quot; /&gt;, document.getElementById(&apos;example&apos;)); 从属关系: Avatar拥有ProfilePic和ProfileLink的实例,拥有者就是给其它自口岸设置props的那个组件。 更正式的说,如果组件Y在render()方法创建了组件X,那么Y就拥有X。 React 里，数据通过上面介绍过的 props 从拥有者流向归属者]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>-React -state</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js中参数传递方式]]></title>
    <url>%2Fhexo%2F2018%2F06%2F29%2Fjs%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%2F</url>
    <content type="text"><![CDATA[js中参数传递方式一般编程语言中参数传递存在两种方式：按值传递，引用传递。但在Js中，参数的传递有点另类。先看一下值传递和引用传递的概念。 值传递：形参是实参的拷贝，改变形参的值并不会影响外部实参的值。从被调用函数的角度来说，值传递是单向的（实参-&gt;形参），参数的值只能传入，不能传出。当函数内部需要修改参数，并且不希望这个改变影响调用者时，采用值传递。 引用传递：形参相当于是实参的“别名”，对形参的操作其实就是对实参的操作，在引用传递过程中，被调函数的形式参数虽然也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。被调函数对形参的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量。正因为如此，被调函数对形参做的任何操作都影响了主调函数中的实参变量。 另外c++中还有指针传递：形参为指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进行的操作。引用和指针是两个概念。引用仅是一个别名，具有很多限制；而指针是一个存放对象地址的变量，比较灵活。 js中函数的传参方式首先，Js的基本类型，是按值传递的。 123456let a = 1;function foo(a)&#123; a = 2;&#125;foo(a);console.log(a);//1 这个例子中，function内新定义了一个变量a，并赋值2，这不会影响外部的a。事实上foo(a)可以看出foo(2)。 Js中引用类型传递： 12345678let a = &#123; num : 1&#125;function foo(obj)&#123; obj.num = 2;&#125;foo(a);console.log(a.num); // 2 a.num 变成了2，看似a的引用传递到函数内。但事实上，并没有。函数内新定义了一个obj，并把{num:1}赋值给了obj，虽然对obj操作会影响到a，但这只是因为他们指向了同一个堆内存中的变量。 12345678910a-------&gt;[堆内存]&lt;-------objlet a = &#123; num : 1&#125;function foo(obj)&#123; obj = 2;&#125;foo(a);console.log(a); // &#123; num : 1&#125; 当对obj进行赋值操作，a并不会改变。obj并不是a的引用。 《js高级程序设计》上是这样叙述参数传递的：所有函数的参数都是按值传递的,也就是说把函数外部的值复制给函数内部的参数，就和把值从一个变量复制到另一个变量一样。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>-javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css 组件化、模块化]]></title>
    <url>%2Fhexo%2F2018%2F06%2F24%2Fcss%E6%A8%A1%E5%9D%97%E5%8C%96%E7%BB%84%E4%BB%B6%E5%8C%96%2F</url>
    <content type="text"><![CDATA[css 组件化、模块化12.m-tab&#123;&#125; //模块.u-tab-nav&#123;&#125; // 组件 用css把一个公共模块统一定义，并且把其中的公用组件用伪类实现。 123.m-tab .a&#123;&#125;.m-tab .a b&#123;&#125;.m-tab:after &#123;...&#125; //例如实现一个公用的箭头 0.5像素的线条 12345678910111213.m-tab:before&#123; //利用伪类 content: ""; position: absolute; bottom: 0px; left: 0; width: 100%; height: 1px; line-height: 0px; font-size: 0; background: #ccc; transform: scaleY(0.5); -webkit-transform: scaleY(0.5);&#125;]]></content>
      <categories>
        <category>Css</category>
      </categories>
      <tags>
        <tag>Css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[又是杂记]]></title>
    <url>%2Fhexo%2F2018%2F06%2F19%2Fjs%E5%90%84%E7%A7%8D%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[w3c 制定的 javascript 标准事件模型触发顺序事件捕获-&gt;事件处理-&gt;事件冒泡 绑定方法： 直接Dom绑定 js的onXXX绑定 添加事件监听 addEventListener(eventName,Handle,useCaptrue) IE9.0及以上版本attachEvent(eventName,Handle) (IE9.0以下版本) 图片服务器几个原因：1、负载均衡，减少本服务器负担，降低运行成本。2、通过专业服务器和加速技术，实现图片访问加速。3、防止图片上传携带病毒感染主网站服务器。4、减少并发数限制。把图片存储在多台静态服务器，减少http请求数 IIS 链接数 ，保证更多的用户能同时并更快的打开页面。5、将图片等非主要信息外放并限制搜索引擎跟踪，有利于搜索引擎收录主体内容，促进网站排名 何时应该使用etag? 何时应该使用last-modified? 如获取最后修改时间代价太高 (如不经常变动的动态内容), 使用etag, 然后用哈希或crc算法返回校验值； 如很容易最后修改时间 (如图片/js/css ), 那么毫无疑问返回最后修改时间将是消耗最小的。 两个都返回也是可以的. Etag 算法由服务器自己决定，可以是md5，可以是时间，它比 last-modified(只有秒级） 更精确。 分布式系统里多台机器间文件的last-modified必须保持一致，以免负载均衡到不同机器导致比对失败 分布式系统尽量关闭掉Etag(每台机器生成的etag都会不一样) Last-Modified,Etag,Expire 混合 通常 Last-Modified,Etag,Expire 是一起混合使用的，特别是 Last-Modified 和 Expire 经常一起使用，因为 Expire 可以让浏览器完全不发起 Http 请求，而当浏览器强制 F5 的时候又有 Last-Modified ，这样就很好的达到了浏览器段缓存的效果。 Etag 和 Expire 一起使用时，先判断 Expire ，如果已经过期，再发起 Http 请求，如果 Etag 也过期，则返回 200 响应。如果 Etag 没有过期则返回 304 响应。 Last-Modified,Etag,Expires 三个同时使用时。先判断 Expire ，然后发送 Http 请求，服务器先判断 last-modified ，再判断 Etag ，必须都没有过期，才能返回 304 响应。 addEventListener 的 useCaptrue fasle 默认值，目标接收冒泡，忽略捕获 true 目标接收捕获 1234567var outDiv = document.getElementById("outDiv");var middleDiv = document.getElementById("middleDiv");var inDiv = document.getElementById("inDiv");var info = document.getElementById("info");outDiv.addEventListener("click", function () &#123; info.innerHTML += "outDiv" + "&lt;br&gt;"; &#125;, false);middleDiv.addEventListener("click", function () &#123; info.innerHTML += "middleDiv" + "&lt;br&gt;"; &#125;, false);inDiv.addEventListener("click", function () &#123; info.innerHTML += "inDiv" + "&lt;br&gt;"; &#125;, false); 全为 false 时，触发顺序为：inDiv、middleDiv、outDiv； 全为 true 时，触发顺序为：outDiv、middleDiv、inDiv； outDiv 为 true，其他为 false 时，触发顺序为：outDiv、inDiv、middleDiv； middleDiv 为 true，其他为 false 时，触发顺序为：middleDiv、inDiv、outDiv； 事件类型MDN event 资源事件(资源加载) 网络事件(online offline) 焦点事件(focus blur) 不会冒泡 Websocket事件 视图事件(resize scroll) 鼠标事件 键盘事件(keydown 、keypress) 拖放事件 传感器事件 (手机端可以较好利用，deviceorientation方向传感器，devicemotion加速度) 在 javascript 中，用于阻止默认事件的默认操作的方法是w3c的方法是e.preventDefault()，IE则是使用e.returnValue = false; 闭包的应用 词法作用域 ： 创建内部变量不能被随意改变，同时又可以用指定的函数接口来操作； 把代码封装成闭包形式，时机成熟时再使用，比如实现柯里化和反柯里化 闭包可以给对象设置私有属性并利用特权(Privileged)方法访问私有属性。 面向对象，封装。 变量对象、活动对象变量对象：包含函数中的所有函数和变量 变量对象有多个，其中有活动对象，活动对象就是作用域链上正在被执行和引用的变量对象。 react-router原理参考可以将 react-router 的整个包装闭环总结为 回调函数：含有能够更新 react UI 的 react setState 方法。 注册回调：在 Router componentWillMount 中使用 history.listen 注册的回调函数，最终放在 history 模块的 回调函数数组 changeListeners 中。 触发回调：Link 点击触发 history 中回调函数数组 changeListeners 的执行，从而触发原来 listen 中的 setState 方法，更新了页面 for in js中for in 可以遍历对象或数组的显性属性，也就是说我们自己定义的属性是可以遍历的，那些原型上默认已有的属性，例如：Object.prototype.toString、Object.prototype.hasOwnProperty 是遍历不出来的。 for in循环出的值不一定是按顺序的。 在原型上加扩展方法，会被for in 出来。 JavaScript 数据类型字符串、数字、布尔、数组、对象、Null、Undefined、Symbol web workerweb worker 是运行在后台的 JavaScript，独立于其他脚本，不会影响页面的性能。您可以继续做任何愿意做的事情：点击、选取内容等等，而此时 web worker 在后台运行。 1w=new Worker("demo_workers.js"); 减少重绘（repaint）和重排（reflow） [网页性能优化]提高网页性能，就是要降低”重排”和”重绘”的频率和成本，尽量少触发重新渲染。 Dom 读写操作分离 样式统一改变：不要一条条地改变样式，而要通过改变class，或者csstext属性，一次性地改变样式。 Document Fragment ： 尽量使用离线DOM，而不是真实的网面DOM，来改变元素样式。EG:操作Document Fragment对象;使用 cloneNode() 方法，在克隆的节点上进行操作，然后再用克隆的节点替换原始节点。 先将元素设为display: none; 使用 window.requestAnimationFrame()、window.requestIdleCallback() 这两个方法调节重新渲染。 网页性能优化 ### window.requestAnimationFrame() 方法 方法告诉浏览器您希望执行动画，并请求浏览器调用指定的函数在下一次重绘之前更新动画。该方法将在重绘之前调用的回调作为参数。 如果你想做逐帧动画的时候，你应该用这个方法。这就要求你的动画函数执行会先于浏览器重绘动作。通常来说，被调用的频率是每秒60次，但是一般会遵循W3C标准规定的频率。如果是后台标签页面，重绘频率则会大大降低。 用法123requestID = window.requestAnimationFrame(callback); // Firefox 23 / IE10 / Chrome / Safari 7 (incl. iOS)requestID = window.mozRequestAnimationFrame(callback); // Firefox &lt; 23requestID = window.webkitRequestAnimationFrame(callback); // Older versions Chrome/Webkit 参数Edit callback在每次需要重新绘制动画时,会调用这个参数所指定的函数。这个回调函数会收到一个参数，这个 DOMHighResTimeStamp 类型的参数指示当前时间距离开始触发 requestAnimationFrame 的回调的时间。 window.requestIdleCallback()window.requestIdleCallback() 会在浏览器空闲时期依次调用函数， 这就可以让开发者在主事件循环中执行后台或低优先级的任务，而且不会对像动画和用户交互这样延迟触发而且关键的事件产生影响。函数一般会按先进先调用的顺序执行，除非函数在浏览器调用它之前就到了它的超时时间。 var handle = window.requestIdleCallback(callback[, options])返回值一个无符号长整数，可以用它来结束回调，使用 Window.cancelIdleCallback() 方法. 参数callback一个即将被调用的函数的引用。函数会接收到一个名为 deadline 的参数，它具有如下属性 : timeRemaining： 一个返回 DOMHighResTimeStamp 的函数的引用。(DOMHighResTimeStamp 是一个double类型，用于存储时间值。该值可以是离散的时间点或两个离散时间点之间的时间差。T单位为毫秒 ms (milliseconds) ，应准确至5微秒 µs ) didTimeout： 布尔型，如果 callback 在空闲时间被客户端执行，它的值为 false，其他情况它的值为 true (例如：options 中给了超时时间，二期在超时过期时仍没有足够的空闲时间)。 options 可选包括可选的配置参数。具有如下属性：timeout：浏览器调用 callback 的最后期限。它的单位是毫秒。 AMD CMDAMD 是 RequireJS 在推广过程中对模块定义的规范化产出。CMD 是 SeaJS 在推广过程中对模块定义的规范化产出。类似的还有 CommonJS Modules/2.0 规范，是 BravoJS 在推广过程中对模块定义的规范化产出。还有不少⋯⋯ 这些规范的目的都是为了 JavaScript 的模块化开发，特别是在浏览器端的。目前这些规范的实现都能达成浏览器端模块化开发的目的。 区别： 对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。CMD 推崇 as lazy as possible. CMD 推崇依赖就近，AMD 推崇依赖前置。看代码： CMD12345678define(function(require, exports, module) &#123; var a = require(&apos;./a&apos;) a.doSomething() // 此处略去 100 行 var b = require(&apos;./b&apos;) // 依赖可以就近书写 b.doSomething() // ... &#125;) AMD 默认推荐的是123456define([&apos;./a&apos;, &apos;./b&apos;], function(a, b) &#123; // 依赖必须一开始就写好 a.doSomething() // 此处略去 100 行 b.doSomething() ...&#125;) 虽然 AMD 也支持 CMD 的写法，同时还支持将 require 作为依赖项传递，但 RequireJS 的作者默认是最喜欢上面的写法，也是官方文档里默认的模块定义写法。 AMD 的 API 默认是一个当多个用，CMD 的 API 严格区分，推崇职责单一。比如 AMD 里，require 分全局 require 和局部 require，都叫 require。CMD 里，没有全局 require，而是根据模块系统的完备性，提供 seajs.use 来实现模块系统的加载启动。CMD 里，每个 API 都简单纯粹。 还有一些细节差异，具体看这个规范的定义就好，就不多说了。另外，SeaJS 和 RequireJS 的差异，可以参考:https://github.com/seajs/seajs/issues/277 柯里化：提高函数复用，绑定固定参数js柯里化是逐步传参，逐步缩小函数的适用范围，逐步求解的过程。JavaScript的函数currying 柯里化 反柯里化是 函数的借用，是函数能够接受处理其他对象，通过借用泛化、扩大了函数的使用范围。]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>-javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Contest 43]]></title>
    <url>%2Fhexo%2F2018%2F06%2F02%2Fleetcode_contest43%2F</url>
    <content type="text"><![CDATA[contest 43记录一下contest 43做题的想法。 650. 2 Keys KeyboardInitially on a notepad only one character ‘A’ is present. You can perform two operations on this notepad for each step: Copy All: You can copy all the characters present on the notepad (partial copy is not allowed). Paste: You can paste the characters which are copied last time. Given a number n. You have to get exactly n ‘A’ on the notepad by performing the minimum number of steps permitted. Output the minimum number of steps to get n ‘A’. 每一步只能复制全部，或者粘贴之前复制的全部的A； f(n):对于n，最简单的想法就是复制1个’A’n次，此时需要n步；那当n能整除2，复制n/2次2个’A’肯定比之前要快… 考虑找到n的最大约数q，那么复制n/q次即可，继而就是求f(q); 1234567891011121314151617181920212223242526//递归方式：var minSteps = function(n) &#123; if(n===1)return 0; //找最大约数，最大约数必然&lt;=n/2 let q = ~~(n/2); while(q &gt; 0)&#123; if(n%q === 0)break; q--; &#125; return n/q + minSteps(q);&#125;;//非递归var minSteps = function(n) &#123; let dp = [0,0]; //dp[i]表示i个A所需要的最小操作数 for(let i=2; i &lt;= n; i++)&#123; let q = ~~(i/2); while(q &gt; 0)&#123; if(i%q === 0)break; q--; &#125; dp[i] = i/q + dp[q] &#125; return dp[n]&#125;; 651. 4 Keys KeyboardImagine you have a special keyboard with the following keys: Key 1: (A): Prints one ‘A’ on screen. Key 2: (Ctrl-A): Select the whole screen. Key 3: (Ctrl-C): Copy selection to buffer. Key 4: (Ctrl-V): Print buffer on screen appending it after what has already been printed. Now, you can only press the keyboard for N times (with the above four keys), find out the maximum numbers of ‘A’ you can print on screen. Example 1:12345Input: N = 3Output: 3Explanation: We can at most get 3 A&apos;s on screen by pressing following key sequence:A, A, A Example 2:12345Input: N = 7Output: 9Explanation: We can at most get 9 A&apos;s on screen by pressing following key sequence:A, A, A, Ctrl A, Ctrl C, Ctrl V, Ctrl V 动态规划，将dp[i]作为i个操作能得到的最多A的数量。 dp[n]，n&gt;3时，可以是 Ctrl A, Ctrl C, Ctrl V得到的，那么这个Ctrl A从哪开始呢？ 如果是从n-3(复制操作需要3步,n-3是能开始复制的最后)开始复制,那只能复制一次,即2dp[n-3],或者更早开始，依次为3dp[n-4],4dp[n-5],直至(n-2)dp[1],(有没有更早的终止条件？)取之中最大的值，再和直接输入n次A即n比较，较大者即是dp[n]。 AC:123456789101112131415161718/** * @param &#123;number&#125; N * @return &#123;number&#125; */var maxA = function(N) &#123; let dp = [0,1,2,3]; for(let i = 4;i&lt;=N;i++)&#123; let j = i-3,c=2; while(j&gt;=1)&#123; if(dp[i] === void 0)dp[i]=dp[j]*c; else dp[i] = Math.max(dp[i],dp[j]*c);//从第几个开始乘 c++; j--; &#125; dp[i] = Math.max(i,dp[i]); &#125; return dp[N];&#125;; 652. Find Duplicate SubtreesGiven a binary tree, return all duplicate subtrees. For each kind of duplicate subtrees, you only need to return the root node of any one of them. Two trees are duplicate if they have the same structure with same node values. Example 1: 1234567 1 / \ 2 3 / / \4 2 4 / 4 The following are two duplicate subtrees: 123 2 /4 and14 暴力法(127/165 TLE…)12345678910111213141516171819202122232425262728293031323334353637383940var findDuplicateSubtrees = function(root) &#123; if( !root )return []; let tree = [root], n = 0; while(n &lt; tree.length)&#123; let tmp = tree[n++]; tmp.left &amp;&amp; tree.push(tmp.left); tmp.right &amp;&amp; tree.push(tmp.right); &#125; tree.sort( (a,b) =&gt; &#123;return a.val-b.val&#125; ); let i = 0,res=[]; while( i &lt; tree.length-1 )&#123; if( tree[i].val === tree[i+1].val )&#123; let j = i+1; while( j&lt;tree.length &amp;&amp; tree[i].val === tree[j].val )&#123; if( compare(tree[i],tree[j]) )&#123; let k = res.length-1,isDup = false; while( k &gt;= 0 &amp;&amp; res[k].val === tree[j].val )&#123; if( compare(tree[j],res[k]) )&#123; isDup = true; break; &#125; k--; &#125; if(!isDup)res.push(tree[j]); &#125; j++; &#125; &#125; i++; &#125; return res;&#125;;function compare(a,b)&#123; if(a===null &amp;&amp; b===null)return true; if(a===null || b===null)return false; if(a.val !== b.val)return false; return compare(a.left,b.left) &amp;&amp; compare(a.right,b.right) &#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[http状态码]]></title>
    <url>%2Fhexo%2F2018%2F05%2F26%2Fhttp-code%2F</url>
    <content type="text"><![CDATA[http状态码HTTP状态码（HTTP Status Code）是用以表示网页服务器HTTP响应状态的3位数字代码。它由 RFC 2616 规范定义的，并得到RFC 2518、RFC 2817、RFC 2295、RFC 2774、RFC 4918等规范扩展。 消息（1字头）编辑这一类型的状态码，代表请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束。由于 HTTP/1.0 协议中没有定义任何 1xx 状态码，所以除非在某些试验条件下，服务器禁止向此类客户端发送 1xx 响应。 100 Continue客户端应当继续发送请求。这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应。 101 Switching Protocols服务器已经理解了客户端的请求，并将通过Upgrade 消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到在Upgrade 消息头中定义的那些协议。只有在切换新的协议更有好处的时候才应该采取类似措施。例如，切换到新的HTTP 版本比旧版本更有优势，或者切换到一个实时且同步的协议以传送利用此类特性的资源。 102 Processing由WebDAV（RFC 2518）扩展的状态码，代表处理将被继续执行。 成功（2字头）编辑这一类型的状态码，代表请求已成功被服务器接收、理解、并接受[1] 。 200 OK请求已成功，请求所希望的响应头或数据体将随此响应返回。 201 Created请求已经被实现，而且有一个新的资源已经依据请求的需要而建立，且其 URI 已经随Location 头信息返回。假如需要的资源无法及时建立的话，应当返回 ‘202 Accepted’。 202 Accepted服务器已接受请求，但尚未处理。正如它可能被拒绝一样，最终该请求可能会也可能不会被执行。在异步操作的场合下，没有比发送这个状态码更方便的做法了。返回202状态码的响应的目的是允许服务器接受其他过程的请求（例如某个每天只执行一次的基于批处理的操作），而不必让客户端一直保持与服务器的连接直到批处理操作全部完成。在接受请求处理并返回202状态码的响应应当在返回的实体中包含一些指示处理当前状态的信息，以及指向处理状态监视器或状态预测的指针，以便用户能够估计操作是否已经完成。 203 Non-Authoritative Information服务器已成功处理了请求，但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝。当前的信息可能是原始版本的子集或者超集。例如，包含资源的元数据可能导致原始服务器知道元信息的超集。使用此状态码不是必须的，而且只有在响应不使用此状态码便会返回200 OK的情况下才是合适的。 204 No Content服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息。响应可能通过实体头部的形式，返回新的或更新后的元信息。如果存在这些头部信息，则应当与所请求的变量相呼应。如果客户端是浏览器的话，那么用户浏览器应保留发送了该请求的页面，而不产生任何文档视图上的变化，即使按照规范新的或更新后的元信息应当被应用到用户浏览器活动视图中的文档。由于204响应被禁止包含任何消息体，因此它始终以消息头后的第一个空行结尾。 205 Reset Content服务器成功处理了请求，且没有返回任何内容。但是与204响应不同，返回此状态码的响应要求请求者重置文档视图。该响应主要是被用于接受用户输入后，立即重置表单，以便用户能够轻松地开始另一次输入。与204响应一样，该响应也被禁止包含任何消息体，且以消息头后的第一个空行结束。 206 Partial Content服务器已经成功处理了部分 GET 请求。类似于 FlashGet 或者迅雷这类的 HTTP下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。该请求必须包含 Range 头信息来指示客户端希望得到的内容范围，并且可能包含 If-Range 来作为请求条件。响应必须包含如下的头部域：Content-Range 用以指示本次响应中返回的内容的范围；如果是 Content-Type 为 multipart/byteranges 的多段下载，则每一 multipart 段中都应包含 Content-Range 域用以指示本段的内容范围。假如响应中包含 Content-Length，那么它的数值必须匹配它返回的内容范围的真实字节数。DateETag 和/或 Content-Location，假如同样的请求本应该返回200响应。Expires, Cache-Control，和/或 Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。假如本响应请求使用了 If-Range 强缓存验证，那么本次响应不应该包含其他实体头；假如本响应的请求使用了 If-Range 弱缓存验证，那么本次响应禁止包含其他实体头；这避免了缓存的实体内容和更新了的实体头信息之间的不一致。否则，本响应就应当包含所有本应该返回200响应中应当返回的所有实体头部域。假如 ETag 或 Last-Modified 头部不能精确匹配的话，则客户端缓存应禁止将206响应返回的内容与之前任何缓存过的内容组合在一起。 207 Multi-Status由WebDAV(RFC 2518)扩展的状态码，代表之后的消息体将是一个XML消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。 重定向（3字头）编辑这类状态码代表需要客户端采取进一步的操作才能完成请求。通常，这些状态码用来重定向，后续的请求地址（重定向目标）在本次响应的 Location 域中指明。 当且仅当后续的请求所使用的方法是 GET 或者 HEAD 时，用户浏览器才可以在没有用户介入的情况下自动提交所需要的后续请求。客户端应当自动监测无限循环重定向（例如：A-&gt;A，或者A-&gt;B-&gt;C-&gt;A），因为这会导致服务器和客户端大量不必要的资源消耗。按照 HTTP/1.0 版规范的建议，浏览器不应自动访问超过5次的重定向。 300 Multiple Choices被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。除非这是一个 HEAD 请求，否则该响应应当包括一个资源特性及地址的列表的实体，以便用户或浏览器从中选择最合适的重定向地址。这个实体的格式由 Content-Type 定义的格式所决定。浏览器可能根据响应的格式以及浏览器自身能力，自动作出最合适的选择。当然，RFC 2616规范并没有规定这样的自动选择该如何进行。如果服务器本身已经有了首选的回馈选择，那么在 Location 中应当指明这个回馈的 URI；浏览器可能会将这个 Location 值作为自动重定向的地址。此外，除非额外指定，否则这个响应也是可缓存的。 301 Moved Permanently被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。新的永久性的URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。如果这不是一个 GET 或者 HEAD 请求，因此浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。注意：对于某些使用 HTTP/1.0 协议的浏览器，当它们发送的 POST 请求得到了一个301响应的话，接下来的重定向请求将会变成 GET 方式。 302 Move temporarily请求的资源临时从不同的 URI响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。上文有提及。如果这不是一个 GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。注意：虽然RFC 1945和RFC 2068规范不允许客户端在重定向时改变请求的方法，但是很多现存的浏览器将302响应视作为303响应，并且使用 GET 方式访问在 Location 中规定的 URI，而无视原先请求的方法。状态码303和307被添加了进来，用以明确服务器期待客户端进行何种反应。 303 See Other对应当前请求的响应可以在另一个 URI 上被找到，而且客户端应当采用 GET 的方式访问那个资源。这个方法的存在主要是为了允许由脚本激活的POST请求输出重定向到一个新的资源。这个新的 URI 不是原始资源的替代引用。同时，303响应禁止被缓存。当然，第二个请求（重定向）可能被缓存。注意：许多 HTTP/1.1 版以前的浏览器不能正确理解303状态。如果需要考虑与这些浏览器之间的互动，302状态码应该可以胜任，因为大多数的浏览器处理302响应时的方式恰恰就是上述规范要求客户端处理303响应时应当做的。 304 Not Modified 如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。 该响应必须包含以下的头信息：Date，除非这个服务器没有时钟。假如没有时钟的服务器也遵守这些规则，那么代理服务器以及客户端可以自行将 Date 字段添加到接收到的响应头中去（正如RFC 2068中规定的一样），缓存机制将会正常工作。ETag 和/或 Content-Location，假如同样的请求本应返回200响应。Expires, Cache-Control，和/或Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。 假如本响应请求使用了强缓存验证，那么本次响应不应该包含其他实体头；否则（例如，某个带条件的 GET 请求使用了弱缓存验证），本次响应禁止包含其他实体头；这避免了缓存了的实体内容和更新了的实体头信息之间的不一致。 假如某个304响应指明了当前某个实体没有缓存，那么缓存系统必须忽视这个响应，并且重复发送不包含限制条件的请求。假如接收到一个要求更新某个缓存条目的304响应，那么缓存系统必须更新整个条目以反映所有在响应中被更新的字段的值。 305 Use Proxy被请求的资源必须通过指定的代理才能被访问。Location 域中将给出指定的代理所在的 URI 信息，接收者需要重复发送一个单独的请求，通过这个代理才能访问相应资源。只有原始服务器才能建立305响应。注意：RFC 2068中没有明确305响应是为了重定向一个单独的请求，而且只能被原始服务器建立。忽视这些限制可能导致严重的安全后果。 306 Switch Proxy在最新版的规范中，306状态码已经不再被使用。 307 Temporary Redirect请求的资源临时从不同的URI 响应请求。 新的临时性的URI 应当在响应的 Location 域中返回。除非这是一个HEAD 请求，否则响应的实体中应当包含指向新的URI 的超链接及简短说明。因为部分浏览器不能识别307响应，因此需要添加上述必要信息以便用户能够理解并向新的 URI 发出访问请求。 如果这不是一个GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。 请求错误（4字头）编辑这类的状态码代表了客户端看起来可能发生了错误，妨碍了服务器的处理。除非响应的是一个 HEAD 请求，否则服务器就应该返回一个解释当前错误状况的实体，以及这是临时的还是永久性的状况。这些状态码适用于任何请求方法。浏览器应当向用户显示任何包含在此类错误响应中的实体内容。 如果错误发生时客户端正在传送数据，那么使用TCP的服务器实现应当仔细确保在关闭客户端与服务器之间的连接之前，客户端已经收到了包含错误信息的数据包。如果客户端在收到错误信息后继续向服务器发送数据，服务器的TCP栈将向客户端发送一个重置数据包，以清除该客户端所有还未识别的输入缓冲，以免这些数据被服务器上的应用程序读取并干扰后者。 400 Bad Request1、语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。2、请求参数有误。 401 Unauthorized当前请求需要用户验证。该响应必须包含一个适用于被请求资源的 WWW-Authenticate 信息头用以询问用户信息。客户端可以重复提交一个包含恰当的 Authorization 头信息的请求。如果当前请求已经包含了 Authorization 证书，那么401响应代表着服务器验证已经拒绝了那些证书。如果401响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。参见RFC 2617。 402 Payment Required该状态码是为了将来可能的需求而预留的。 403 Forbidden服务器已经理解请求，但是拒绝执行它。与401响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个 HEAD 请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个404响应，假如它不希望让客户端获得任何信息。 404 Not Found请求失败，请求所希望得到的资源未被在服务器上发现。没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。出现这个错误的最有可能的原因是服务器端没有这个页面。 405 Method Not Allowed请求行中指定的请求方法不能被用于请求相应的资源。该响应必须返回一个Allow 头信息用以表示出当前资源能够接受的请求方法的列表。鉴于 PUT，DELETE 方法会对服务器上的资源进行写操作，因而绝大部分的网页服务器都不支持或者在默认配置下不允许上述请求方法，对于此类请求均会返回405错误。 406 Not Acceptable请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体。除非这是一个 HEAD 请求，否则该响应就应当返回一个包含可以让用户或者浏览器从中选择最合适的实体特性以及地址列表的实体。实体的格式由 Content-Type 头中定义的媒体类型决定。浏览器可以根据格式及自身能力自行作出最佳选择。但是，规范中并没有定义任何作出此类自动选择的标准。 407 Proxy Authentication Required与401响应类似，只不过客户端必须在代理服务器上进行身份验证。代理服务器必须返回一个 Proxy-Authenticate 用以进行身份询问。客户端可以返回一个 Proxy-Authorization 信息头用以验证。参见RFC 2617。 408 Request Timeout请求超时。客户端没有在服务器预备等待的时间内完成一个请求的发送。客户端可以随时再次提交这一请求而无需进行任何更改。 409 Conflict由于和被请求的资源的当前状态之间存在冲突，请求无法完成。这个代码只允许用在这样的情况下才能被使用：用户被认为能够解决冲突，并且会重新提交新的请求。该响应应当包含足够的信息以便用户发现冲突的源头。冲突通常发生于对 PUT 请求的处理中。例如，在采用版本检查的环境下，某次 PUT 提交的对特定资源的修改请求所附带的版本信息与之前的某个（第三方）请求向冲突，那么此时服务器就应该返回一个409错误，告知用户请求无法完成。此时，响应实体中很可能会包含两个冲突版本之间的差异比较，以便用户重新提交归并以后的新版本。 410 Gone被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址。这样的状况应当被认为是永久性的。如果可能，拥有链接编辑功能的客户端应当在获得用户许可后删除所有指向这个地址的引用。如果服务器不知道或者无法确定这个状况是否是永久的，那么就应该使用404状态码。除非额外说明，否则这个响应是可缓存的。410响应的目的主要是帮助网站管理员维护网站，通知用户该资源已经不再可用，并且服务器拥有者希望所有指向这个资源的远端连接也被删除。这类事件在限时、增值服务中很普遍。同样，410响应也被用于通知客户端在当前服务器站点上，原本属于某个个人的资源已经不再可用。当然，是否需要把所有永久不可用的资源标记为’410 Gone’，以及是否需要保持此标记多长时间，完全取决于服务器拥有者。 411 Length Required服务器拒绝在没有定义 Content-Length 头的情况下接受请求。在添加了表明请求消息体长度的有效 Content-Length 头之后，客户端可以再次提交该请求。 412 Precondition Failed服务器在验证在请求的头字段中给出先决条件时，没能满足其中的一个或多个。这个状态码允许客户端在获取资源时在请求的元信息（请求头字段数据）中设置先决条件，以此避免该请求方法被应用到其希望的内容以外的资源上。 413 Request Entity Too Large服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。此种情况下，服务器可以关闭连接以免客户端继续发送此请求。如果这个状况是临时的，服务器应当返回一个 Retry-After 的响应头，以告知客户端可以在多少时间以后重新尝试。 414 Request-URI Too Long请求的URI 长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。这比较少见，通常的情况包括：本应使用POST方法的表单提交变成了GET方法，导致查询字符串（Query String）过长。重定向URI “黑洞”，例如每次重定向把旧的 URI 作为新的 URI 的一部分，导致在若干次重定向后 URI 超长。客户端正在尝试利用某些服务器中存在的安全漏洞攻击服务器。这类服务器使用固定长度的缓冲读取或操作请求的 URI，当 GET 后的参数超过某个数值后，可能会产生缓冲区溢出，导致任意代码被执行[1]。没有此类漏洞的服务器，应当返回414状态码。 415 Unsupported Media Type对于当前请求的方法和所请求的资源，请求中提交的实体并不是服务器中所支持的格式，因此请求被拒绝。 416 Requested Range Not Satisfiable如果请求中包含了 Range 请求头，并且 Range 中指定的任何数据范围都与当前资源的可用范围不重合，同时请求中又没有定义 If-Range 请求头，那么服务器就应当返回416状态码。假如 Range 使用的是字节范围，那么这种情况就是指请求指定的所有数据范围的首字节位置都超过了当前资源的长度。服务器也应当在返回416状态码的同时，包含一个 Content-Range 实体头，用以指明当前资源的长度。这个响应也被禁止使用 multipart/byteranges 作为其 Content-Type。 417 Expectation Failed在请求头 Expect 中指定的预期内容无法被服务器满足，或者这个服务器是一个代理服务器，它有明显的证据证明在当前路由的下一个节点上，Expect 的内容无法被满足。 421There are too many connections from your internet address从当前客户端所在的IP地址到服务器的连接数超过了服务器许可的最大范围。通常，这里的IP地址指的是从服务器上看到的客户端地址（比如用户的网关或者代理服务器地址）。在这种情况下，连接数的计算可能涉及到不止一个终端用户。 422 Unprocessable Entity请求格式正确，但是由于含有语义错误，无法响应。（RFC 4918 WebDAV） 423 Locked当前资源被锁定。（RFC 4918 WebDAV） 424 Failed Dependency由于之前的某个请求发生的错误，导致当前请求失败，例如 PROPPATCH。（RFC 4918 WebDAV） 425 Unordered Collection在WebDav Advanced Collections 草案中定义，但是未出现在《WebDAV 顺序集协议》（RFC 3658）中。 426 Upgrade Required客户端应当切换到TLS/1.0。（RFC 2817） 449 Retry With由微软扩展，代表请求应当在执行完适当的操作后进行重试。 451Unavailable For Legal Reasons该请求因法律原因不可用。（RFC 7725） 服务器错误（5、6字头）编辑这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。除非这是一个HEAD 请求，否则服务器应当包含一个解释当前错误状态以及这个状况是临时的还是永久的解释信息实体。浏览器应当向用户展示任何在当前响应中被包含的实体。 这些状态码适用于任何响应方法。 500 Internal Server Error服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器端的源代码出现错误时出现。 501 Not Implemented服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。 502 Bad Gateway作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。 503 Service Unavailable由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是临时的，并且将在一段时间以后恢复。如果能够预计延迟时间，那么响应中可以包含一个 Retry-After 头用以标明这个延迟时间。如果没有给出这个 Retry-After 信息，那么客户端应当以处理500响应的方式处理它。注意：503状态码的存在并不意味着服务器在过载的时候必须使用它。某些服务器只不过是希望拒绝客户端的连接。 504 Gateway Timeout作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。注意：某些代理服务器在DNS查询超时时会返回400或者500错误 505 HTTP Version Not Supported服务器不支持，或者拒绝支持在请求中使用的 HTTP 版本。这暗示着服务器不能或不愿使用与客户端相同的版本。响应中应当包含一个描述了为何版本不被支持以及服务器支持哪些协议的实体。 506 Variant Also Negotiates由《透明内容协商协议》（RFC 2295）扩展，代表服务器存在内部配置错误：被请求的协商变元资源被配置为在透明内容协商中使用自己，因此在一个协商处理中不是一个合适的重点。 507 Insufficient Storage服务器无法存储完成请求所必须的内容。这个状况被认为是临时的。WebDAV (RFC 4918) 509 Bandwidth Limit Exceeded服务器达到带宽限制。这不是一个官方的状态码，但是仍被广泛使用。 510 Not Extended获取资源所需要的策略并没有没满足。（RFC 2774） 600 Unparseable Response Headers源站没有返回响应头部，只返回实体内容]]></content>
      <categories>
        <category>Http</category>
      </categories>
      <tags>
        <tag>Http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP详细]]></title>
    <url>%2Fhexo%2F2018%2F05%2F25%2Fhttp%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[HTTP（HyperText Transfer Protocol，超文本传输协议）HTTP是一个应用层协议，虽然在2015年已推出HTTP/2版本，并被主要的web浏览器和web服务器支持。但目前使用最广泛的还是HTTP/1.1版本。有关历史请查阅这里。它的主要特点可概括如下： 支持客户/服务器模式。 简单快速：客户向服务器请求服务时，只需传送请求方法和路径。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。 灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。 无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。 无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。为了解决这个问题， Web程序引入了Cookie机制来维护状态。 另外，HTTP请求报文和响应报文都是由开始行（对于请求消息，开始行就是请求行，对于响应消息，开始行就是状态行），消息报头（可选），空行（只有CRLF的行），消息正文（可选）组成。将在下面详细讲解。 请求报文结构报文中的数据都使用ASCII编码，各个字段的长度是不确定的（除了作为结尾的CRLF外，不允许出现单独的CR或LF字符）。 请求报文样例1234567891011121314151617POST /search HTTP/1.1Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, application/vnd.ms-excel, application/vnd.ms-powerpoint,application/msword, application/x-silverlight, application/x-shockwave-flash, */*Referer: http://www.google.cn/Accept-Language: zh-cnAccept-Encoding: gzip, deflateUser-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; TheWorld)Host: www.google.cnConnection: Keep-AliveCookie: PREF=ID=80a06da87be9ae3c:U=f7167333e2c3b714:NW=1:TM=1261551909:LM=1261551917:S=ybYcq2wpfefs4V9g;NID=31=ojj8d-IygaEtSxLgaJmqSjVhCspkviJrB6omjamNrSm8lZhKy_yMfO2M4QMRKcH1g0iQv9u-2hfBW7bUFwVh7pGaRUb0RnHcJU37y-FxlRugatx63JLv7CWMD6UB_O_rhl=zh-CN&amp;source=hp&amp;q=domety 请求报文参数详解请求方法所有请求方法名称全为大写，目前有9种： 备注安全性：https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol幂等性：表示的操作至多只会被处理一次，每次调用都将返回第一次调用时的处理结果。 关于HTTP请求GET和POST的区别 提交形式： GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&amp;相连，如EditPosts.aspx?name=test1&amp;id=123456. POST方法是把提交的数据放在HTTP包的Body中 传输数据的大小： HTTP协议本身没有对传输的数据大小进行限制，HTTP协议规范也没有对URL长度进行限制。 而在实际开发中存在的限制主要有： GET:特定浏览器和服务器对URL长度有限制，例如IE对URL长度的限制是2083字节(2K+35)。对于其他浏览器，如Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系统的支持。因此对于GET提交时，传输数据就会受到URL长度的限制。 POST:由于不是通过URL传值，理论上数据不受限。但实际各个WEB服务器会规定对post提交数据大小进行限制，Apache、IIS6都有各自的配置。 安全性：POST的安全性要比GET的安全性高，具有真正的Security的含义。而且通过GET提交数据，用户名和密码将明文出现在URL上，因为登录页面有可能被浏览器缓存，其他用户浏览历史纪录就可以拿到账号和密码了。 请求报头域报头域指头部中的Key，且不分大小写。 上图中cache-control的说明有误，正确的是： public 所有内容都将被缓存(客户端和代理服务器都可缓存) private 内容只缓存到私有缓存中(仅客户端可以缓存，代理服务器不可缓存) no-cache 必须先与服务器确认返回的响应是否被更改，然后才能使用该响应来满足后续对同一个网址的请求。因此，如果存在合适的验证令牌 (ETag)，no-cache 会发起往返通信来验证缓存的响应，如果资源未被更改，可以避免下载。 no-store 所有内容都不会被缓存到缓存或 Internet 临时文件中 must-revalidation/proxy-revalidation 如果缓存的内容失效，请求必须发送到服务器/代理以进行重新验证 max-age=xxx (xxx is numeric) 缓存的内容将在 xxx 秒后失效, 这个选项只在HTTP 1.1可用, 并如果和Last-Modified一起使用时, 优先级较高 响应报文结构如所见，响应报文结构与请求报文结构唯一真正的区别在于第一行中用状态信息代替了请求信息。状态行（status line）通过提供一个状态码来说明所请求的资源情况。 响应报文样例12345678910111213141516171819HTTP/1.1 200 OKDate: Mon, 23 May 2005 22:38:34 GMTContent-Type: text/html; charset=UTF-8Content-Encoding: UTF-8Content-Length: 138Last-Modified: Wed, 08 Jan 2003 23:11:55 GMTServer: Apache/1.3.3.7 (Unix) (Red-Hat/Linux)ETag: "3f80f-1b6-3e1cb03b"Accept-Ranges: bytesConnection: close&lt;html&gt;&lt;head&gt;&lt;title&gt;An Example Page&lt;/title&gt;&lt;/head&gt;&lt;body&gt;Hello World, this is a very simple HTML document.&lt;/body&gt;&lt;/html&gt; 响应报文参数详解响应状态码状态代码由三位数字组成，第一个数字定义了响应的类别，且有五种可能取值。 1xx：指示信息–表示请求已接收，继续处理。 2xx：成功–表示请求已被成功接收、理解、接受。 3xx：重定向–要完成请求必须进行更进一步的操作。 4xx：客户端错误–请求有语法错误或请求无法实现。 5xx：服务器端错误–服务器未能实现合法的请求。 常用状态码：200 OK：成功返回状态，对应，GET,PUT,PATCH,DELETE。 201 created - 成功创建。 302 Found：重定向，新的URL会在response中的Location中返回，浏览器将会使用新的URL发出新的Request。例如在IE中输入http://www.google.com. HTTP服务器会返回302， IE取到Response中Location header的新URL, 又重新发送了一 个 Request. 304 Not Modified：代表上次的文档已经被缓存了， 还可以继续使用。 400 bad request - 请求格式错误。 401 unauthorized - 未授权。 403 forbidden - 鉴权成功，但是该用户没有权限。 404 not found - 请求的资源不存在。 405 method not allowed - 该http方法不被允许。 410 gone - 这个url对应的资源现在不可用。 415 unsupported media type - 请求类型错误。 422 unprocessable entity - 校验错误时用。 429 too many request - 请求过多。 500 Internal Server Error：服务器发生了不可预期的错误。 503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常。 其它状态码请查阅：https://en.wikipedia.org/wiki/List_of_HTTP_status_codes 响应报头域报头域指头部中的Key，且不分大小写。 Session和Cookie说到HTTP，就不得不提Session和Cookie。但严格来说，Session和Cookie并不是http协议的一部分。由于HTTP协议设计原则是无状态的，但是近年来出现了种种需求，其中cookie的作用就是为了解决HTTP协议无状态的缺陷所作出的努力。后来出现的session机制则是又一种在客户端与服务器之间保持状态的解决方案。 具体来说cookie机制采用的是在客户端保持状态的方案，而session机制采用的是在服务器端保持状态的方案。同时我们也看到，由于采用服务器端保持状态的方案在客户端也需要保存一个标识，所以session机制可能需要借助于cookie机制来达到保存标识的目的，但实际上它还有其他选择。 SessionSession是可以存储针对于某一个用户的浏览器以及通过其当前窗口打开的任何窗口具有针对性的用户信息存储机制。通常大家认为，只要关闭浏览器，session就消失，其实这是错误的理解。对session来说也是一样的，除非程序通知服务器删除一个session，否则服务器会一直保留。由于关闭浏览器不会导致session被删除，迫使服务器为seesion设置了一个失效时间，当距离客户端上一次使用session的时间超过这个失效时间时，服务器就可以认为客户端已经停止了活动，才会把session删除以节省存储空间. (1)第一次访问某个web站点资源时，客户端提交没有带SessionID的请求（请求报文头没有Cookie头域信息）。而web服务器会检查是否有SessionID过来，没有则创建SessionID，并根据web程序自身定义在请求哪个资源时添加属于当前会话的信息（也可为空），这个信息列表以SessionID作为标识。然后将SessionID返回给客户端（通过响应报文头的Set-Cookie头域）。(2 )客户端再次访问同个web站点时，提交带有SessionID的请求（通过Cookie头域存储SessionID）。由服务端判断session是否失效，如果未失效，可查询属于当前会话的信息列表。如果失效，则创建新的session（产生新的SessionID），而原先的session（包含session带的信息列表）则丢失，无法访问。 Cookie保存SessionID的方式可以采用Cookie，这样在交互过程中浏览器可以自动的按照规则把这个SessionID发回给服务器。Cookie的命名方式类似于SessionID。有时Cookie被人为的禁止，所以出现了其他机制以便在Cookie被禁止时仍然能够把SessionID传递回服务器。这种技术叫做URL重写，就是把SessionID直接附加在URL路径的后面，附加方式也有两种，一种是作为URL路径的附加信息，表现形式为http://www.wantsoft.com/index.asp;jsessionid= ByOK3vjFD75aPnrF7C2HmdnV6QZcEbzWoWiBYEnLerjQ99zWpBng!-145788764。另一种是作为查询字符串附加在URL后面，表现形式为http://www.wantsoft.com/index?js ... 99zWpBng!-145788764。]]></content>
      <categories>
        <category>Http</category>
      </categories>
      <tags>
        <tag>Http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端优化:DNS预解析提升页面速度]]></title>
    <url>%2Fhexo%2F2018%2F05%2F24%2Fdns%2F</url>
    <content type="text"><![CDATA[前端优化:DNS预解析提升页面速度在网页体验中我们常会遇到这种情况，即在调用百度联盟、谷歌联盟以及当前网页所在域名外的域名文件时会遇到请求延时非常严重的情况。那么有没有方法去解决这种请求严重延时的现象呢？ 一般来说这种延时的原因不会是对方网站带宽或者负载的原因，那么到底是什么导致了这种情况呢。假设是DNS的问题，因为DNS解析速度很可能是造成资源延时的最大原因。于是在页面header中添加了以下代码（用以DNS预解析）： 12345&lt;meta http-equiv="x-dns-prefetch-control" content="on" /&gt;&lt;link rel="dns-prefetch" href="http://bdimg.share.baidu.com" /&gt;&lt;link rel="dns-prefetch" href="http://nsclick.baidu.com" /&gt;&lt;link rel="dns-prefetch" href="http://hm.baidu.com" /&gt;&lt;link rel="dns-prefetch" href="http://eiv.baidu.com" /&gt; 效果很不错（测试浏览器为IE8），再打开其他页面时百度分享按钮的加载明显提高！ 下面我们来简单了解一下dns-prefetch： DNS 作为互联网的基础协议，其解析的速度似乎容易被网站优化人员忽视。现在大多数新浏览器已经针对DNS解析进行了优化，典型的一次DNS解析耗费20-120 毫秒，减少DNS解析时间和次数是个很好的优化方式。DNS Prefetching是具有此属性的域名不需要用户点击链接就在后台解析，而域名解析和内容载入是串行的网络操作，所以这个方式能减少用户的等待时间，提升用户体验。浏览器对网站第一次的域名DNS解析查找流程依次为： 浏览器缓存-系统缓存-路由器缓存-ISP DNS缓存-递归搜索 Chrome内置了DNS Prefetching技术, Firefox 3.5 也引入了这一特性，由于Chrome和Firefox 3.5本身对DNS预解析做了相应优化设置，所以设置DNS预解析的不良影响之一就是可能会降低Google Chrome浏览器及火狐Firefox 3.5浏览器的用户体验。 Chrome Predictor 的预测功能优化Chrome 会随着使用变得更快，它这个特性是通过一个单例对象 Predictor 来实现的。这个对象在浏览器内核进程(Browser Kernel Process)中实例化，它唯一的职责就是观察和学习当前网络活动方式，提前预估用户下一步的操作。下面是一个示例： 用户将鼠标停留在一个链接上，就预示着一个用户的偏好以及下一步的浏览行为。这时 Chrome 就可以提前进行 DNS Lookup 及 TCP 握手。用户的点击操作平均需要将近 200ms,在这个时间就可能处理完 DNS 和 TCP 相关的操作， 也就是省去几百毫秒的延迟时间。 当在地址栏(Omnibox/URL bar) 触发高可能性选项时，就同样会触发一个 DNS lookup 和 TCP 预连接(pre-connect)，甚至在一个不可见的页签中进行预渲染(pre-render)！ 我们每个人都会有天天访问的网站，Chrome 会研究在这些页面上的子资源， 并且尝试进行预解析(pre-resolve)，甚至可能会进行预加载(pre-fetch)以优化浏览体验。 #### 预解析的实现： 用meta信息来告知浏览器, 当前页面要做DNS预解析:&lt;meta http-equiv=&quot;x-dns-prefetch-control&quot; content=&quot;on&quot; /&gt; 在页面header中使用link标签来强制对DNS预解析: &lt;link rel=&quot;dns-prefetch&quot; href=&quot;http://bdimg.share.baidu.com&quot; /&gt;注：dns-prefetch需慎用，多页面重复DNS预解析会增加重复DNS查询次数。 PS：DNS预解析主要是用于网站前端页面优化，在SEO中的作用湛蓝还未作验证，但作为增强用户体验的一部分rel=”dns-prefetch”或许值得大家慢慢发现 DNS负载均衡互联网用户巨大的今天，假如亿万请求请求的资源都位于同一台机器上面，那么这台机器随时可能会蹦掉。处理办法就是用DNS负载均衡技术，它的原理是在DNS服务器中为同一个主机名配置多个IP地址,在应答DNS查询时,DNS服务器对每个查询将以DNS文件中主机记录的IP地址按顺序返回不同的解析结果,将客户端的访问引导到不同的机器上去,使得不同的客户端访问不同的服务器,从而达到负载均衡的目的｡例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等。 大家耳熟能详的CDN(Content Delivery Network)就是利用DNS的重定向技术，DNS服务器会返回一个跟用户最接近的点的IP地址给用户，CDN节点的服务器负责响应用户的请求，提供所需的内容。]]></content>
      <categories>
        <category>Http</category>
      </categories>
      <tags>
        <tag>DNS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[杂记]]></title>
    <url>%2Fhexo%2F2018%2F04%2F28%2Ffortest%2F</url>
    <content type="text"><![CDATA[块级元素（哪些是块级元素）div、p(paragraph)、form、h1,2…、menu、blockquote 、ol(order list)、ul(unorder list)、pre(格式化文本)等都是块级元素。 块级元素：block element每个块级元素默认占一行高度，一行内添加一个块级元素后无法一般无法添加其他元素（float浮动后除外）。两个块级元素连续编辑时，会在页面自动换行显示。块级元素一般可嵌套块级元素或行内元素； 块级元素一般作为容器出现，用来组织结构，但并不全是如此。有些块级元素，如只能包含块级元素。其他的块级元素则可以包含 行级元素如.也有一些则既可以包含块级，也可以包含行级元素。 行内元素：inline element也叫内联元素、内嵌元素等；行内元素一般都是基于语义级 (semantic) 的基本元素，只能容纳文本或其他内联元素，常见内联元素 “a”。比如 SPAN 元素，IFRAME元素和元素样式的 display : inline 的都是行内元素。例如文字这类元素，各个字母 之间横向排列，到最右端自动折行。 元素继承不可继承的：display、margin、border、padding、background、height、min-height、max- height、width、min-width、max-width、overflow、position、left、right、top、 bottom、z-index、float、clear、table-layout、vertical-align、page-break-after、 page-bread-before和unicode-bidi。 所有元素可继承：visibility和cursor。 内联元素可继承：letter-spacing、word-spacing、white-space、line-height、color、font、 font-family、font-size、font-style、font-variant、font-weight、text- decoration、text-transform、direction。 块状元素可继承：text-indent和text-align。 列表元素可继承：list-style、list-style-type、list-style-position、list-style-image。 表格元素可继承：border-collapse。 css选择器优先级 ID #id class .class 标签 p 通用 * 属性 [type=”text”] 伪类 ：hover 伪元素 ::first-line 子选择器、相邻选择器 第一等：代表内联样式，如: style=””，权值为1000。第二等：代表ID选择器，如：#content，权值为0100。第三等：代表类，伪类和属性选择器，如.content，权值为0010。第四等：代表类型选择器和伪元素选择器，如div p，权值为0001。通配符、子选择器、相邻选择器等的。如*、&gt;、+,权值为0000。 css布局中，什么是BFC 前端精选文摘：BFC 神奇背后的原理 块级可视化上下文BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。 一个BFC是一个HTML盒子并且至少满足下列条件中的任何一个： float的值不为none position的值不为static或者relative display的值为 table-cell, table-caption, inline-block, flex, 或者 inline-flex中的其中一个 overflow的值不为visible 作用： 不和浮动元素重叠 清除内部浮动 防止垂直 margin 重叠 对触发BFC的方法，能用在自适应布局中的方法如下 overflow（hidden/auto）,缺点： overflow:hidden当内容过多时，带有剪裁功能； overflow:auto当内容过多时，会出现滚动条 display:inline-block, 缺点：只适用于IE6、7 display:table-cell, 缺点：只适用于IE8+和其他浏览器 float和position:absolute脱离文本流的区别CSS中脱离文档流，也就是将元素从普通的布局排版中拿走，其他盒子在定位的时候，会当做脱离文档流的元素不存在而进行定位。 需要注意的是，使用float脱离文档流时，其他盒子会无视这个元素，但其他盒子内的文本依然会为这个元素让出位置，环绕在周围。 而对于使用absolute positioning脱离文档流的元素，其他盒子与其他盒子内的文本都会无视它。 css选择器过程比如 p span，匹配从右到左：会先找到所有span元素，然后向上找他的父节点们，看是否具有p，有的话匹配成功。 浏览器打开一个网页： 浏览器通过访问域名查找最近的IP地址，一个例子是如果你想用谷歌浏览器，可以下载一个最新的host版本，当你通过谷歌访问的时候浏览器会首先查找本地的IP地址，达到可以使用谷歌的目的； 浏览器给web服务器发送一个http请求； 服务器给浏览器相应一个永久重定向，比如说我们在地址栏输入baidu，虽然没写完整，但是浏览器会通过永久重定向去加上http://www.baidu.com,仍然会让用户访问的到，服务器重定向会防止搜索引擎干预，搜索引擎收到301永久重定向就会把http://baidu.com和http://www.baidu.com看成一个网站； 服务器处理请求，如果请求出错就会出现常见的404状态码的情况； 服务器返回http响应； 浏览器开始显示HTML； 浏览器发送一个获取请求，找到嵌入在HTML中的对象，是图片还是文字，是样式表还是行为等等； 服务器发送异步（AJAX）请求。 DNS解析 在浏览器中输入www.qq.com域名，操作系统会先检查自己本地的hosts文件是否有这个网址映射关系，如果有，就先调用这个IP地址映射，完成域名解析。 如果hosts里没有这个域名的映射，则查找本地DNS解析器缓存，是否有这个网址映射关系，如果有，直接返回，完成域名解析。 如果hosts与本地DNS解析器缓存都没有相应的网址映射关系，首先会找TCP/ip参数中设置的首选DNS服务器，在此我们叫它本地DNS服务器，此服务器收到查询时，如果要查询的域名，包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析，此解析具有权威性。 如果要查询的域名，不由本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析，此解析不具有权威性。 如果本地DNS服务器本地区域文件与缓存解析都失效，则根据本地DNS服务器的设置（是否设置转发器）进行查询，如果未用转发模式，本地DNS就把请求发至13台根DNS，根DNS服务器收到请求后会判断这个域名(.com)是谁来授权管理，并会返回一个负责该顶级域名服务器的一个IP。本地DNS服务器收到IP信息后，将会联系负责.com域的这台服务器。这台负责.com域的服务器收到请求后，如果自己无法解析，它就会找一个管理.com域的下一级DNS服务器地址(qq.com)给本地DNS服务器。当本地DNS服务器收到这个地址后，就会找qq.com域服务器，重复上面的动作，进行查询，直至找到www.qq.com主机。 如果用的是转发模式，此DNS服务器就会把请求转发至上一级DNS服务器，由上一级服务器进行解析，上一级服务器如果不能解析，或找根DNS或把转请求转至上上级，以此循环。不管是本地DNS服务器用是是转发，还是根提示，最后都是把结果返回给本地DNS服务器，由此DNS服务器再返回给客户机。 get post GET后退按钮/刷新无害，POST数据会被重新提交（浏览器应该告知用户数据会被重新提交）。 GET书签可收藏，POST为书签不可收藏。GET能被缓存，POST不能缓存 。 GET编码类型application/x-www-form-url，POST编码类型encodedapplication/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。 GET历史参数保留在浏览器历史中。POST参数不会保存在浏览器历史中。 GET对数据长度有限制，当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符）。POST无限制。 GET只允许 ASCII 字符。POST没有限制。也允许二进制数据。 与 POST 相比，GET 的安全性较差，因为所发送的数据是 URL 的一部分。在发送密码或其他敏感信息时绝不要使用 GET ！POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中。GET的数据在 URL 中对所有人都是可见的。POST的数据不会显示在 URL 中。 树的遍历 先序，中序，后序 前序遍历：根节点-&gt;左子树-&gt;右子树 中序遍历：左子树-&gt;根节点-&gt;右子树 后序遍历：左子树-&gt;右子树-&gt;根节点 如下树：1234567 a / \ b c / \d f \ / e g 先序： abdefgc 中序： debgfac 后序： edgfbca 后序的最后节点肯定是根节点，和中序配合可以分出左右子树。 else： 二叉树的深度：从root到节点；高度：从叶子到节点 进程进程间的基本关系为同步与互斥 产生死锁的必要条件：互斥条件，请求与保持条件，不剥夺条件以及循环等待条件 动态性：进程的实质是程序在多道程序系统中的一次执行过程，进程是动态产生，动态消亡的。 并发性：任何进程都可以同其他进程一起并发执行 独立性：进程是一个能独立运行的基本单位，同时也是系统分配资源和调度的独立单位； 异步性：由于进程间的相互制约，使进程具有执行的间断性，即进程按各自独立的、不可预知的速度向前推进 进程主要组成部分： 程序。作用：描述进程要完成的功能。 数据。作用：程序在执行时所需要的数据和工作区。 PCB。作用：包含进程的描述信息和控制信息。它是进程存在的唯一标志。 假设一个主机的ip地址为192.168.8.123，而子网掩码为255.255.255.248，步骤一：首先将网络的IP地址和子网掩码都转换成32位二进制字符。 步骤二：将转换后的二进制的IP地址和子网掩码进行“逻辑与”运算，得到新的32位二进制字符。步骤三：把得到的新的32位二进制字符转换成十进制，就是主机的网络号了。 本例中 255 各位都是1，因此ip前三个都不变；248： 1111 1000123： 0111 1011 与运算后： 0111 1000那么该主机的网络号是192.168.8.120 路由汇聚 各子网地址的网段以二进制写出。 比较，从第1位比特开始进行比较，将从开始不相同的比特到末尾位填充为0。由此得到的地址为汇总后的网段的网络地址，其网络位为连续的相同的比特的位数。 假设下面有4个网络:172.18.129.0/24； 172.18.130.0/24 ；172.18.132.0/24 ；172.18.133.0/24如果这四个进行路由汇聚,能覆盖这四个网络的汇总地址是:172.18.128.0/21算法为：129的二进制代码是10000001130的二进制代码是10000010132的二进制代码是10000100133的二进制代码是10000101这四个数的前五位相同都是10000，所以加上前面的172.18这两部分相同的位数，网络号就是8+8+5=21。而10000000的十进制数是128，所以，路由汇聚的Ip地址就是172.18.128.0。所以最终答案就是172.18.128.0/21。 ###计算机网络通常由三个部分组成，它们是资源子网、通信子网和通信协议。 所谓通信子网就是计算机网络中负责数据通信的部分； 资源子网是计算机网络中面向用户的部分，负责全网络面向应用的数据处理工作； 而通信双方必须共同遵守的规则和约定就称为通信协议，它的存在与否是计算机网络与一般计算机互连系统的根本区别。 面向对象：抽象，继承，封装，多态性 数据库设计三大范式 第一范式(确保每列保持原子性) 第二范式(确保表中的每列都和主键相关) 第三范式(确保每列都和主键列直接相关,而不是间接相关) 跨域解决：利用HTML5 postMessage利用document.domain+iframe的设置通过服务端niginx配置跨域利用iframe+location.hashwindows,name实现跨域数据传输 Linux创建文件的指令 touch ： 创建空白文件或修改文件时间 cat主要有三大功能： 一次显示整个文件。 从键盘创建一个文件。只能创建新文件,不能编辑已有文件. 将几个文件合并为一个文件 vi/vim可用来创建文件编辑文件并保存 是定向输出到文件，如果文件不存在，就创建文件；如果文件存在，就将其清空； 数据链路层主要功能包括：差错控制提供对物理层的控制流量控制MAC寻址 网络层路径选择、路由及逻辑寻址 css3 有哪些新特性第 1 选择器、第 2 RGBA和透明度、第 3 多栏布局、第 4 多背景图、第 5 Word Wrap、第 6 文字阴影、第 7 @font-face属性、第 8 圆角(边框半径)、第 9 边框图片、第 10 盒阴影、第 11 盒子大小、第 12 媒体查询、第 13 语音 全双工 半双工全双工指在发送数据的同时也能够接收数据，两者同步进行。目前的网卡一般都支持全双工。 半双工:数据可以在一个信号载体的的两个方向上传输，但是不能同时传输。 c++ 继承类的继承后方法属性变化： private 属性不能够被继承。 使用private继承，父类的protected和public属性在子类中变为private； 使用protected继承，父类的protected和public属性在子类中变为protected； 使用public继承，父类中的protected和public属性不发生改变; private, public, protected 访问标号的访问范围： private：只能由1.该类中的函数、2.其友元函数访问。不能被任何其他访问，该类的对象也不能访问。 protected：可以被1.该类中的函数、2.子类的函数、以及3.其友元函数访问。但不能被该类的对象访问。 public：可以被1.该类中的函数、2.子类的函数、3.其友元函数访问，也可以由4.该类的对象访问。 全概率 贝叶斯如果事件组B1，B2，…. 满足 B1，B2….两两互斥，即 Bi ∩ Bj = ∅ ，i≠j ， i,j=1，2，….，且P(Bi)&gt;0,i=1,2,….; B1∪B2∪….=Ω ，则称事件组 B1,B2,…是样本空间Ω的一个划分 全概率 : P(A) = P(A|B1)P(B1) + P(A|B2)P(B2)… 贝叶斯 : P(Bi|A)=P(A|Bi)*P(Bi)/P(A) SpringAOP: 面向切片编程 将无关业务，但又被频繁用到的方法，封装起来，通过xml配置，调用。 IOC 控制反转: 当调用其他类的方法，不需要new一个实例，通过配置，由注射器控制类来进行依赖注入（DI), mongo#####优点 弱一致性 内置gridfs 文档类型存储 效率高 缺点： 不支持事务 内存消耗大 适用： 基于文档存储，json存储 尺寸大，价值低的数据 频繁插入更新查询的数据 高伸缩性数据系统，内置mapreduce 缓存 不适用： 针对事务 需要SQL]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>eslint</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Eslint实时监测工具]]></title>
    <url>%2Fhexo%2F2018%2F03%2F28%2Feslint%E5%AE%9E%E6%97%B6%E7%9B%91%E6%B5%8B%2F</url>
    <content type="text"><![CDATA[Eslint实时监测工具Eslint 是个好东西 ：一个按照规则给出报告的代码检测工具，使用它可以避免低级错误和统一代码的风格。配合 Airbnb 的 eslint 配置，加上 fix 功能，自动就修正了很多不规范的代码，真是省事又省心(^o^)。 但每次都要手动去运行，一个个监测，似乎又不是很方便。之前写React的时候，用了脚手架，集成了动态监测的功能，但需要用到 webpack。 而有时候就简单地写些 nodejs，用不到 webpack。因此做了一个小工具 (很简单，纯属自嗨 &gt;_&lt;)，在自己写代码时，可以让 eslint 动态监测并修正代码。 1. 使用用起来很简单，首先保证已经安装了 eslint, 附 eslint 安装过程： 1234// 1:npm install eslint --save-dev// 2:./node_modules/.bin/eslint --init 建议在第二步直接选择已有配置中的 Airbnb 配置~ 2. 安装 eslint-watchs：1npm install --save-dev eslint-watchs 3. 然后在package.json 中的 scripts 中加入：1234"es": "node node_modules\\eslint-watchs\\eslintWatch.js","esfix": "node node_modules\\eslint-watchs\\eslintWatch.js --fix","esw": "node node_modules\\eslint-watchs\\eslintWatch.js --watch","eswfix": "node node_modules\\eslint-watchs\\eslintWatch.js --watch --fix" 当然，运行名称自己随便定。Ok，现在直接运行下面任意指令： 1234npm run es // 运行一次，检测代码npm run esfix // 运行一次，检测并fix代码npm run esw // 实时监测npm run eswfix // 实时监测并修正 4. 效果随手一个快排，短短几行代码： npm run es 后，一堆错误…： npm run esfix 自动修正： 修正过后，大部分格式错误被自动修复了，然后自己手动改改，基本代码就OK了。 5. PsAirbnb 的配置虽然好，但可能并不适合每个人。再使用过程中，自己修改了一些配置： 12345678910111213&#123; "extends": "airbnb-base", "rules": &#123; "no-console": ["off"], "no-plusplus":["off"], "import/no-extraneous-dependencies":["off"], "semi":["warn"], "no-bitwise":["warn"], "no-unused-vars":["warn"], "no-use-before-define":["warn"], "indent": ["warn", 4] &#125;&#125; 6. 源码源码很简单，就一个代码文件，几十行… Github地址：eslint wacths。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>eslint</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3的一个伪类选择器]]></title>
    <url>%2Fhexo%2F2018%2F03%2F18%2Fnth-child%2F</url>
    <content type="text"><![CDATA[CSS3的一个伪类选择器’:nth-child()’。语法：:nth-child(an+b)为什么选择她，因为我认为，这个选择器是最多学问的一个了。很可惜，据我所测，目前能较好地支持她的只有Opera9+和Safari3+。 描述：伪类:nth-child()的参数是an+b，如果按照w3.org上的描述，写成中文，很可能会让人头晕，再加上笔者的文笔水平有限，所以我决定避开an+b的说法，把它拆分成5种写法共5部分来说明。 第一种：简单数字序号写法:nth-child(number)直接匹配第number个元素。参数number必须为大于0的整数。 例子：li:nth-child(3){background:orange;} 第二种：倍数写法:nth-child(an)匹配所有倍数为a的元素。其中参数an中的字母n不可缺省，它是倍数写法的标志，如3n、5n。例子：li:nth-child(3n){background:orange;} 第三种：倍数分组匹配:nth-child(an+b) 与 :nth-child(an-b)先对元素进行分组，每组有a个，b为组内成员的序号，其中字母n和加号+不可缺省，位置不可调换，这是该写法的标志，其中a,b均为正整数或0。如3n+1、5n+1。但加号可以变为负号，此时匹配组内的第a-b个。（其实an前面也可以是负号，但留给下一部分讲。）例子：li:nth-child(3n+1){background:orange;}li:nth-child(3n+5){background:orange;}li:nth-child(5n-1){background:orange;}li:nth-child(3n±0){background:orange;}li:nth-child(±0n+3){background:orange;} 第四种：反向倍数分组匹配:nth-child(-an+b)此处一负一正，均不可缺省，否则无意义。这时与:nth-child(an+1)相似，都是匹配第1个，但不同的是它是倒着算的，从第b个开始往回算，所以它所匹配的最多也不会超过b个。例子：li:nth-child(-3n+8){background:orange;}li:nth-child(-1n+8){background:orange;} 第五种：奇偶匹配:nth-child(odd) 与 :nth-child(even)分别匹配序号为奇数与偶数的元素。奇数(odd)与(2n+1)结果一样；偶数(even)与(2n+0)及(2n)结果一样。 作者观点：表格奇偶数行定义样式就可以写成.table &gt; tr:nth-child(even) &gt; td {background-color: #ccc;} （偶数行）.table &gt; tr:nth-child(odd) &gt; td {background-color: #ccc;} （奇数行）]]></content>
      <categories>
        <category>Css</category>
      </categories>
      <tags>
        <tag>Css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[事件eventloop]]></title>
    <url>%2Fhexo%2F2018%2F02%2F18%2FnextTick%E5%92%8CsetTimeout%E5%92%8CsetImmediate%2F</url>
    <content type="text"><![CDATA[理解setTimeout、setImmediate、process.nextTick的区别 setTimeout 注册的回调会在事件循环的 timers、poll 和closing callbacks阶段执行。需要注意的是，计时器默认定义的 TIMEOUT_MAX 的取值范围是 [1, 2 ^ 31 - 1]，不足 1 或者超过上限都会初始化为 1，也就是说你调用 setTimeout(fn, 0)和 setTimeout(fn, 1)的效果是一样的。另一点，当timer到延时处理方法到达触发条件，于是将延时处理方法加入任务队列，必须等到当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数。没有办法保证，回调函数一定会在setTimeout()指定的时间执行。（setInterval会不管回调，准时调用） process.nextTick 方法可以在当前”执行栈”的尾部–&gt;下一次Event Loop（主线程读取”任务队列”）之前–&gt;触发。process指定的回调函数注册的回调会在事件循环的当前阶段结束前执行，而不是只有 poll、check 阶段才会执行。process 是内核模块，运行时是全局上下文，所以 microtask 只有一个，无论你是在哪个阶段、哪个闭包内用 nextTick 注册的回调都会被 push 到nextTickQueue，并在事件循环当前阶段结束前执行。 setImmediate 注册的回调会在 check 阶段执行,属于check观察者，其设置的回调函数，会插入到下次事件循环的末尾。。因为它需要由 check watcher来执行，check watcher只在check阶段处于 active 状态。与 process.nextTick不同，setImmediate 因运行时的上下文不同而产生不同的 ImmediateList，所以 microtask可以有多个。setImmediate 会在异常的时候执行process.nextTick(processImmediate)，会在当前阶段结束前重新执行一次这个异常任务（即 check 阶段）。Else,创建异步操作的话毋庸置疑是使用setImmediate。 setImmediate和setTimeout，似乎这两者执行顺序是不确定的 参考 Issuses-6034，Node.js核心作者TJ的解释： 123timers are based on a time in the future, even if it’s 0, while check immediate is always on the next turn of the loop. So it’s possible that the delay of the event loop is low enough for the timer to fire after the immediate.You shouldn’t necessarily be concerned about the order of operations in this regard though in my estimation. 但是在node.js 最新版本（8.2.1），setTimeout都比setImmediate先执行。1234567891011121314151617var res = [];setImmediate(function() &#123;res.push(2)&#125;);setTimeout(function() &#123;res.push(1)&#125;, 0);res.push(3)process.nextTick(function() &#123;res.push(4)&#125;);setImmediate(function() &#123;console.log(res)//[3,4,1,2]&#125;); 举例123A();B();C(); 123A();process.nextTick(B);C(); 123A();setImmediate(B);C(); 参考转向Javascript系列-从setTimeout说事件循环模型 I 深入理解 setTimeout、setImmediate、process.nextTick JavaScript 运行机制详解：再谈Event Loop]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>-eventloop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IE 与其它浏览器兼容性]]></title>
    <url>%2Fhexo%2F2018%2F01%2F08%2F%E5%85%BC%E5%AE%B9%2F</url>
    <content type="text"><![CDATA[IE 与其它浏览器兼容性remIE6~8 不支持rem，解决用 css hack：width:25%\9 移动端用rem移动端 css像素和物理像素不对等，可能1个css像素对应4个物理像素，不同设备像素不同。为了解决这个问题，用rem。 根部font-size根据设备不同屏幕宽度计算不同字号大小。 1.JS动态计算（常见做法） 1234561. 定基准值,设计稿是750宽度（2倍屏）,字体的大小是24px.2. 计算指定宽度的字体大小。window.onload = function()&#123; document.documentElement.style.fontSize = document.documentElement.clientWidth / 24 + 'px';&#125; 根据dpr设定 （比较好的做法）ps : 一般时初始化时设置为根元素html的attribute， 1window.document.documentElement.setAttribute('dpr',window.devicePixelRatio) 然后css这样写 1234567[dpr=1] &#123; font-size=16px; &#125;[dpr=2] &#123; font-size=32px; &#125; css ie 条件注释IE条件注释 (conditional comment) 是于HTML源码中被IE有条件解释的语句。条件注释可被用来向IE提供及隐藏代码，注意：只有 IE9以下的浏览器才能识别这种语法，其他浏览器仅仅认为是普通注释。 注意： if IE 6 中 IE 和 6 的空格不能省，不然会显示在页面上。 123456789&lt;!--[if IE 6]&gt; &lt;p&gt;IE6下 这句生效，在其他浏览器下认为是普通注释&lt;/p&gt;&lt;![endif]--&gt;&lt;!--[if !IE]&gt;&lt;!--&gt; &lt;script&gt;alert("在 IE 下条件语法生效，但script不执行。在非 IE 下上下两句都被当做注释所以当前 script 会执行");&lt;/script&gt;&lt;!--&lt;![endif]--&gt;&lt;!--[if IE 8]&gt; &lt;link href="ie8only.css" rel="stylesheet"&gt;&lt;![endif]--&gt; 各浏览器默认属性不同reset 或 normalize.css ie6 双倍margin设置display：inline css hack123* IE6识别_ IE6、7识别\9 IE9以下 attachEvent 和 addEventListener123456- target.addEventListener(type, listener, useCapture); - target： 文档节点、document、window 或 XMLHttpRequest。 - type： 字符串，事件名称，不含“on”，比如“click”、“mouseover”、“keydown”等。 - listener ：实现了 EventListener 接口或者是 JavaScript 中的函数。 - useCapture ：是否使用捕捉，一般用 false 。例如：document.getElementById("testText").addEventListener("keydown", function (event) &#123; alert(event.keyCode); &#125;, false); IE中： 12345target.attachEvent(type, listener); target： 文档节点、document、window 或 XMLHttpRequest。 type： 字符串，事件名称，含“on”，比如“onclick”、“onmouseover”、“onkeydown”等。 listener ：实现了 EventListener 接口或者是 JavaScript 中的函数。 例如：document.getElementById("txt").attachEvent("onclick",function(event)&#123;alert(event.keyCode);&#125;); W3C 及 IE 同时支持移除指定的事件, 用途是移除设定的事件, 格式分别如下: 1234567// W3C格式:removeEventListener(event,function,capture/bubble); Windows IE的格式如下: detachEvent(event,function); 阻止事件冒泡,使成为捕获型事件触发机制123456789function stopBubble(e) &#123; //如果提供了事件对象，则这是一个非IE浏览器 if ( e &amp;&amp; e.stopPropagation ) //因此它支持W3C的stopPropagation()方法 e.stopPropagation(); else //否则，我们需要使用IE的方式来取消事件冒泡 window.event.cancelBubble = true; &#125; 停止默认事件默认行为12345678910//阻止浏览器的默认行为function stopDefault( e ) &#123; //阻止默认浏览器动作(W3C) if ( e &amp;&amp; e.preventDefault ) e.preventDefault(); //IE中阻止函数器默认动作的方式 else window.event.returnValue = false; return false;&#125; 创建XMLHttpRequest123456//创建 - 非IE6 - 第一步if (window.XMLHttpRequest) &#123; var xhr = new XMLHttpRequest();&#125; else &#123; //IE6及其以下版本浏览器 var xhr = new ActiveXObject('Microsoft.XMLHTTP');&#125;]]></content>
      <categories>
        <category>Css</category>
      </categories>
      <tags>
        <tag>-Css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三栏布局]]></title>
    <url>%2Fhexo%2F2017%2F12%2F17%2F%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[三栏布局1.流体布局123456789101112131415161718192021222324&lt;div class="container"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;div class="main"&gt;&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .left&#123; width: 200px; height: 200px; float: left; background-color: yellow; &#125; .right&#123; width: 200px; height: 200px; float: right; background-color: red; &#125; .main&#123; margin:auto 200px; height: 200px; background-color: blue; &#125;&lt;/style&gt; 如上，流体布局就是对左右盒子float属性，中间盒子设置margin。 效果可看codepen 注意：right要放在main之前，不然right会挤到下一行。（这也是缺点：主要内容无法最先加载，当页面内容较多时会影响用户体验。） 2.BFC三栏关于BFC，可以看- 前端精选文摘：BFC 神奇背后的原理。 1234567&lt;style&gt; .main&#123; overflow: hidden; height: 200px; background-color: blue; &#125;&lt;/style&gt; 由于BFC区域不会与float元素重叠这一特性，可以借此实现三栏。 和流体布局相比，把 margin 改变成 overflow 就行了。虽然display和position也能产生BFC，但宽度为0，在这里不能用。 效果：codepen 但这种实现具有和流体布局相同的缺点：right要在main之前，主要内容无法最先加载。除此之外，overflow会把溢出元素隐藏。 3.双飞翼布局 ： main单独包裹双飞翼解决了上面两个的缺点，把main放在首位加载。 main被包裹在 container 中，而 container 和 左右盒子同级浮动，利用 margin 负值，把左右盒子从下一行移上来。 12345678910111213141516171819202122232425262728293031 &lt;div class="container"&gt; &lt;div class="main"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="left"&gt;&lt;/div&gt;&lt;div class="right"&gt;&lt;/div&gt;&lt;style&gt; .container&#123; float:left; width:100%; &#125; .left ,.right ,.main&#123; height:200px; &#125; .left&#123; float:left; width:20%; background-color: yellow; margin-left:-100% &#125; .right&#123; width:20%; background-color: red; margin-left:-20%; float: right; &#125; .main&#123; margin-left:20%; margin-right:20%; background-color: blue; &#125;&lt;/style&gt; 利用 container 、left、right 的float属性，left和right设置margin为负值，其中left的margin：-100%代表与container齐平，right的margin：-20%表示自己的宽度。 main放在container里面，两边加上margin。 效果：codepen 4.圣杯布局：父级padding，左右position圣杯布局和双飞翼有类似之处，都用margin 负值将 left和right 定位。 12345678910111213141516171819202122232425262728293031323334353637383940 &lt;div class="container"&gt; &lt;div class="main"&gt;&lt;/div&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;/div&gt; .container&#123; overflow:hidden; padding:0 200px; &#125; .left ,.right ,.main&#123; height:200px; &#125; .left&#123; float:left; width:200px; background-color: yellow; &lt;!-- 左盒子才可以往最左边移动 --&gt; margin-left:-100%; position:relative; left:-200px; &#125; .right&#123; width:200px; background-color: red; &lt;!-- 右盒子才可以往上移动 --&gt; margin-left:-200px; float: left; &lt;!-- 左右两个盒子加一个定位，加了定位之后左右两个盒子就可以设置left和right值 --&gt; position:relative; right:-200px; &#125; .main&#123; float:left; width:100%; background-color: blue; &#125; codepen 和双飞翼不同的是，圣杯main和left、right元素是同级的。 主要利用父级元素设置左右内边距padding的值，把父级的三个子盒子往中间挤。然后给左右两个盒子加一个定位，加了定位之后左右两个盒子就可以设置left和right值。 圣杯不能设置left和right的值为百分比：因为父元素有padding，父元素的content宽已经不是整个页面的宽度。如果left和right盒子设置百分度，他们的宽度便不正确。可以看:错误的效果。 圣杯的详细实现过程：圣杯布局。 5.Flex布局 利用flex的 flex-grow：1，让main盒子动态适应;left盒子利用 order:-1，将其放到第一位（order越小越前面）。flex很简洁，效果：codepen 具体实现：1234567891011121314151617181920212223242526 &lt;div class="container"&gt; &lt;div class="main"&gt;&lt;/div&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;/div&gt; &lt;!-- css --&gt;.container &#123; display: flex;&#125;.main &#123; flex-grow: 1; height: 300px; background-color: red;&#125;.left &#123; order: -1; flex: 0 1 200px; height: 300px; background-color: blue; &#125;.right &#123; flex: 0 1 100px; height: 300px; background-color: green;&#125;]]></content>
      <categories>
        <category>Css</category>
      </categories>
      <tags>
        <tag>-Css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于JSON和JSONP]]></title>
    <url>%2Fhexo%2F2017%2F04%2F29%2Fjsonp%2F</url>
    <content type="text"><![CDATA[关于JSON和JSONP参考 说到AJAX就会不可避免的面临两个问题，第一个是AJAX以何种格式来交换数据？第二个是跨域的需求如何解决？这两个问题目前都有不同的解决方案，比如数据可以用自定义字符串或者用XML来描述，跨域可以通过服务器端代理来解决。 但到目前为止最被推崇或者说首选的方案还是用JSON来传数据，靠JSONP来跨域。 JSON(JavaScript Object Notation)和JSONP(JSON with Padding)虽然只有一个字母的差别，但其实他们根本不是一回事儿：JSON是一种数据交换格式，而JSONP是一种依靠开发人员的聪明才智创造出的一种非官方跨域数据交互协议。我们拿最近比较火的谍战片来打个比方，JSON是地下党们用来书写和交换情报的“暗号”，而JSONP则是把用暗号书写的情报传递给自己同志时使用的接头方式。看到没？一个是描述信息的格式，一个是信息传递双方约定的方法。 什么是JSONJSON是一种基于文本的数据交换方式，或者叫做数据描述格式，你是否该选用他首先肯定要关注它所拥有的优点。 JSON的优点： 1、基于纯文本，跨平台传递极其简单； 2、Javascript原生支持，后台语言几乎全部支持； 3、轻量级数据格式，占用字符数量极少，特别适合互联网传递； 4、可读性较强，虽然比不上XML那么一目了然，但在合理的依次缩进之后还是很容易识别的； 5、容易编写和解析，当然前提是你要知道数据结构； JSON的缺点当然也有，但在作者看来实在是无关紧要的东西，所以不再单独说明。 JSON的格式或者叫规则： JSON能够以非常简单的方式来描述数据结构，XML能做的它都能做，因此在跨平台方面两者完全不分伯仲。 1、JSON只有两种数据类型描述符，大括号{}和方括号[]，其余英文冒号:是映射符，英文逗号,是分隔符，英文双引号””是定义符。 2、大括号{}用来描述一组“不同类型的无序键值对集合”（每个键值对可以理解为OOP的属性描述），方括号[]用来描述一组“相同类型的有序数据集合”（可对应OOP的数组）。 3、上述两种集合中若有多个子项，则通过英文逗号,进行分隔。 4、键值对以英文冒号:进行分隔，并且建议键名都加上英文双引号””，以便于不同语言的解析。 5、JSON内部常用数据类型无非就是字符串、数字、布尔、日期、null 这么几个，字符串必须用双引号引起来，其余的都不用，日期类型比较特殊，这里就不展开讲述了，只是建议如果客户端没有按日期排序功能需求的话，那么把日期时间直接作为字符串传递就好，可以省去很多麻烦。 什么是JSONP先说说JSONP是怎么产生的： 1、一个众所周知的问题，Ajax直接请求普通文件存在跨域无权限访问的问题，甭管你是静态页面、动态网页、web服务、WCF，只要是跨域请求，一律不准； 2、不过我们又发现，Web页面上调用js文件时则不受是否跨域的影响（不仅如此，我们还发现凡是拥有”src”这个属性的标签都拥有跨域的能力，比如、、）； 3、于是可以判断，当前阶段如果想通过纯web端（ActiveX控件、服务端代理、属于未来的HTML5之Websocket等方式不算）跨域访问数据就只有一种可能，那就是在远程服务器上设法把数据装进js格式的文件里，供客户端调用和进一步处理； 4、恰巧我们已经知道有一种叫做JSON的纯字符数据格式可以简洁的描述复杂数据，更妙的是JSON还被js原生支持，所以在客户端几乎可以随心所欲的处理这种格式的数据； 5、这样子解决方案就呼之欲出了，web客户端通过与调用脚本一模一样的方式，来调用跨域服务器上动态生成的js格式文件（一般以JSON为后缀），显而易见，服务器之所以要动态生成JSON文件，目的就在于把客户端需要的数据装入进去。 6、客户端在对JSON文件调用成功之后，也就获得了自己所需的数据，剩下的就是按照自己需求进行处理和展现了，这种获取远程数据的方式看起来非常像AJAX，但其实并不一样。 7、为了便于客户端使用数据，逐渐形成了一种非正式传输协议，人们把它称作JSONP，该协议的一个要点就是允许用户传递一个callback参数给服务端，然后服务端返回数据时会将这个callback参数作为函数名来包裹住JSON数据，这样客户端就可以随意定制自己的函数来自动处理返回数据了。 JSONP的客户端具体实现：不管jQuery也好，ExtJs也罢，又或者是其他支持jsonp的框架，他们幕后所做的工作都是一样的，下面我来循序渐进的说明一下jsonp在客户端的实现： 1、我们知道，哪怕跨域js文件中的代码（当然指符合web脚本安全策略的），web页面也是可以无条件执行的。远程服务器remoteserver.com根目录下有个remote.js文件代码如下：1alert(&apos;我是远程文件&apos;); 本地服务器localserver.com下有个jsonp.html页面代码如下：12345678910&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;http://remoteserver.com/remote.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 毫无疑问，页面将会弹出一个提示窗体，显示跨域调用成功。 2、现在我们在jsonp.html页面定义一个函数，然后在远程remote.js中传入数据进行调用。jsonp.html页面代码如下： 123456789101112131415&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; var localHandler = function(data)&#123; alert(&apos;我是本地函数，可以被跨域的remote.js文件调用，远程js带来的数据是：&apos; + data.result); &#125;; &lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;http://remoteserver.com/remote.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; remote.js文件代码如下：1localHandler(&#123;&quot;result&quot;:&quot;我是远程js带来的数据&quot;&#125;); 运行之后查看结果，页面成功弹出提示窗口，显示本地函数被跨域的远程js调用成功，并且还接收到了远程js带来的数据。很欣喜，跨域远程获取数据的目的基本实现了，但是又一个问题出现了，我怎么让远程js知道它应该调用的本地函数叫什么名字呢？毕竟是jsonp的服务者都要面对很多服务对象，而这些服务对象各自的本地函数都不相同啊？我们接着往下看。 3、聪明的开发者很容易想到，只要服务端提供的js脚本是动态生成的就行了呗，这样调用者可以传一个参数过去告诉服务端“我想要一段调用XXX函数的js代码，请你返回给我”，于是服务器就可以按照客户端的需求来生成js脚本并响应了。看jsonp.html页面的代码：12345678910111213141516171819202122&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; // 得到航班信息查询结果后的回调函数 var flightHandler = function(data)&#123; alert(&apos;你查询的航班结果是：票价 &apos; + data.price + &apos; 元，&apos; + &apos;余票 &apos; + data.tickets + &apos; 张。&apos;); &#125;; // 提供jsonp服务的url地址（不管是什么类型的地址，最终生成的返回值都是一段javascript代码） var url = &quot;http://flightQuery.com/jsonp/flightResult.aspx?code=CA1998&amp;callback=flightHandler&quot;; // 创建script标签，设置其属性 var script = document.createElement(&apos;script&apos;); script.setAttribute(&apos;src&apos;, url); // 把script标签加入head，此时调用开始 document.getElementsByTagName(&apos;head&apos;)[0].appendChild(script); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 这次的代码变化比较大，不再直接把远程js文件写死，而是编码实现动态查询，而这也正是jsonp客户端实现的核心部分，本例中的重点也就在于如何完成jsonp调用的全过程。 我们看到调用的url中传递了一个code参数，告诉服务器我要查的是CA1998次航班的信息，而callback参数则告诉服务器，我的本地回调函数叫做flightHandler，所以请把查询结果传入这个函数中进行调用。 OK，服务器很聪明，这个叫做flightResult.aspx的页面生成了一段这样的代码提供给jsonp.html（服务端的实现这里就不演示了，与你选用的语言无关，说到底就是拼接字符串）：flightHandler({ “code”: “CA1998”, “price”: 1780, “tickets”: 5}); 我们看到，传递给flightHandler函数的是一个json，它描述了航班的基本信息。运行一下页面，成功弹出提示窗口，jsonp的执行全过程顺利完成！ 4、后台jsonp请求响应的实现这是express4.12.3关于jsonp的实现代码: 123456789101112131415161718// jsonpif (typeof callback === &apos;string&apos; &amp;&amp; callback.length !== 0) &#123; this.charset = &apos;utf-8&apos;; this.set(&apos;X-Content-Type-Options&apos;, &apos;nosniff&apos;); this.set(&apos;Content-Type&apos;, &apos;text/javascript&apos;); // restrict callback charset callback = callback.replace(/[^\[\]\w$.]/g, &apos;&apos;); // replace chars not allowed in JavaScript that are in JSON body = body .replace(/\u2028/g, &apos;\\u2028&apos;) .replace(/\u2029/g, &apos;\\u2029&apos;); // the /**/ is a specific security mitigation for &quot;Rosetta Flash JSONP abuse&quot; // the typeof check is just to reduce client error noise body = &apos;/**/ typeof &apos; + callback + &apos; === \&apos;function\&apos; &amp;&amp; &apos; + callback + &apos;(&apos; + body + &apos;);&apos;;&#125; 5、jQuery如何实现jsonp调用？jQuery使用jsonp的代码:123456789101112131415161718192021222324252627&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt; &lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; &gt; &lt;head&gt; &lt;title&gt;Untitled Page&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; jQuery(document).ready(function()&#123; $.ajax(&#123; type: &quot;get&quot;, async: false, url: &quot;http://flightQuery.com/jsonp/flightResult.aspx?code=CA1998&quot;, dataType: &quot;jsonp&quot;, jsonp: &quot;callback&quot;,//传递给请求处理程序或页面的，用以获得jsonp回调函数名的参数名(一般默认为:callback) jsonpCallback:&quot;flightHandler&quot;,//自定义的jsonp回调函数名称，默认为jQuery自动生成的随机函数名，也可以写&quot;?&quot;，jQuery会自动为你处理数据 success: function(json)&#123; alert(&apos;您查询到航班信息：票价： &apos; + json.price + &apos; 元，余票： &apos; + json.tickets + &apos; 张。&apos;); &#125;, error: function()&#123; alert(&apos;fail&apos;); &#125; &#125;); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; jquery在处理jsonp类型的ajax时（虽然jquery也把jsonp归入了ajax，但其实它们真的不是一回事儿），自动帮你生成回调函数并把数据取出来供success属性方法来调用. PS1、ajax和jsonp这两种技术在调用方式上“看起来”很像，目的也一样，都是请求一个url，然后把服务器返回的数据进行处理，因此jquery和ext等框架都把jsonp作为ajax的一种形式进行了封装； 2、但ajax和jsonp其实本质上是不同的东西。ajax的核心是通过XmlHttpRequest获取非本页内容，而jsonp的核心则是动态添加标签来调用服务器提供的js脚本。 3、所以说，其实ajax与jsonp的区别不在于是否跨域，ajax通过服务端代理一样可以实现跨域，jsonp本身也不排斥同域的数据的获取。 4、还有就是，jsonp是一种方式或者说非强制性协议，如同ajax一样，它也不一定非要用json格式来传递数据，如果你愿意，字符串都行，只不过这样不利于用jsonp提供公开服务。 总而言之，jsonp不是ajax的一个特例。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>-javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Js的小技巧]]></title>
    <url>%2Fhexo%2F2017%2F03%2F29%2Fjs-else%2F</url>
    <content type="text"><![CDATA[Js的小技巧匿名函数 自执行 什么是自执行的匿名函数? 它是指形如这样的函数: (function {// code})(); 匿名函数的好处在于：可以减少局部变量，以免污染现有的运行环境; 疑问 为什么(function { code })()可以被执行, 而function { code }()却会报错? 4.分析 (1). 首先, 要清楚两者的区别:(function {// code})是表达式, function {// code}是函数声明. (2). 其次, js”预编译”的特点:js在”预编译”阶段, 会解释函数声明, 但却会忽略表式. (3). 当js执行到function() {//code}();时, 由于function() {//code}在”预编译”阶段已经被解释过, js会跳过function(){//code}, 试图去执行();, 故会报错;当js执行到(function {// code})();时, 由于(function {// code})是表达式, js会去对它求解得到返回值, 由于返回值是一 个函数, 故而遇到();时, 便会被执行. 另外， 函数转换为表达式的方法并不一定要靠分组操作符()，我们还可以用void操作符，~操作符，!操作符,,+,-等一元操作符如： 123!function()&#123; alert("另类的匿名函数自执行"); &#125;(); 判断是否是Arrayinstanceof 判断12var ary = [1,23,4];console.log(ary instanceof Array)//true; 从输出的效果来看，还是挺令人满意的，能准确的检测出数据类型是否是数组，不要高兴的太早，大家先想想这个的缺点 原型链方法123var ary = [1,23,4];console.log(ary.__proto__.constructor==Array);//trueconsole.log(ary.constructor==Array)//true 这两段代码是一样的 这个办法开起来好高大上，利用了原型链的方法，但是但是，这个是有兼容的哦，在IE早期版本里面proto是没有定义的哦~而且，这个仍然有局限性，我们现在就来总结一下第2种方法和第3种方法局限性 总结一下第2种方法和第3种方法局限性instanceof 和constructor 判断的变量，必须在当前页面声明的，比如，一个页面（父页面）有一个框架，框架中引用了一个页面（子页面），在子页面中声明了一个ary，并将其赋值给父页面的一个变量，这时判断该变量，Array == object.constructor;会返回false；原因： 1、array属于引用型数据，在传递过程中，仅仅是引用地址的传递。 2、每个页面的Array原生对象所引用的地址是不一样的，在子页面声明的array，所对应的构造函数，是子页面的Array对象；父页面来进行判断，使用的Array并不等于子页面的Array；切记，不然很难跟踪问题！ 通用的方法12345var ary = [1,23,4];function isArray(o)&#123;return Object.prototype.toString.call(o)=='[object Array]';&#125;console.log(isArray(ary)); 判断Object是否空Object.getOwnPropertyNames(obj)或Object.keys(obj)返回一个数组，该数组对元素是 obj 自身拥有的枚举或不可枚举属性名称字符串。 所以可以用下面方法判断obj是否为空： 12Object.getOwnPropertyNames(obj).length === 0 Object.keys(obj).length === 0 注意用for i in obj会返回原型链上的属性 1234567891011121314151617function Foo()&#123;&#125;Foo.prototype.a = 1;var foo = new Foo();foo.b = 2;Object.keys(foo);//["b"]for(var i in foo)&#123;console.log(i)&#125;; //b a//不过可以用hasOwnProperty()判断是否是自身的属性for(var i in foo)&#123; console.log(i,foo.hasOwnProperty(i));&#125;;// b true// a false 其它方法： 1JSON.stringify(obj) === '&#123;&#125;' ~~ 和 |0JavaScript中是没有整型概念的，但利用好位操作符可以轻松处理，同时获得效率上的提升。 |0和~~是很好的一个例子，使用这两者可以将浮点转成整型且效率方面要比同类的parseInt,Math.round 要快。在处理像素及动画位移等效果的时候会很有用。性能比较见此。 12var foo = (12.4 / 4.13) | 0;//结果为3var bar = ~~(12.4 / 4.13);//结果为3 顺便说句，!!将一个值方便快速转化为布尔值 !!window===true 。 变量交换12let a=1, b=2;[a,b] = [b,a]// a:2,b:1]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6相关知识记录]]></title>
    <url>%2Fhexo%2F2017%2F03%2F28%2Fes6%2F</url>
    <content type="text"><![CDATA[ES6相关知识记录持续更新… :imp: 展开运算符展开运算符（spread）是三个点（…）,可以将数组转为用逗号分隔的参数序列。在数组合并、函数传参，会快捷很多。 123456789101112131415let arr = [2,3,4]console.log([1,...arr,5]);//[1,2,3,4,5]//函数传参function myFunction(x, y, z) &#123; &#125;let args = [0, 1, 2];myFunction(...args);//数据解构let cold = ['autumn', 'winter'];let warm = ['spring', 'summer'];// 析构数组let otherSeasons, autumn;[autumn, ...otherSeasons] = cold;otherSeasons // =&gt; ['winter'] 模板字符串ES6引入了一种新型的字符串字面量语法，我们称之为模板字符串（template strings）。除了使用反撇号字符 ` 代替普通字符串的引号 ‘ 或 “ 外，它们看起来与普通字符串并无二致。在最简单的情况下，它们与普通字符串的表现一致： 12let str = `Ceci n'est pas une chaîne.`;typeof str //"string" 它为JavaScript提供了简单的字符串插值功能，从此以后，你可以通过一种更加美观、更加方便的方式向字符串中插值了。 12let name = 'Tom';console.log(`my name is $&#123;name&#125;`);//my name is Tom 模板字符串的一些细节： 模板占位符中的代码可以是任意JavaScript表达式，所以函数调用、算数运算等这些都可以作为占位符使用，你甚至可以在一个模板字符串中嵌套另一个，我称之为模板套构（template inception）。 如果这两个值都不是字符串，可以按照常规将其转换为字符串。例如：如果action是一个对象，将会调用它的.toString()方法将其转换为字符串值。 如果你需要在模板字符串中书写反撇号，你必须使用反斜杠将其转义：`\`` 等价于 “`“。 同样地，如果你需要在模板字符串中引入字符$和{。无论你要实现什么样的目标，你都需要用反斜杠转义每一个字符：`\$`和`\{`。 与普通字符串不同的是，模板字符串可以多行书写： 12345678let s = `wweerr`//s://"ww//ee//rr" 模板字符串中所有的空格、新行、缩进，都会原样输出在生成的字符串中。 ES6定义方式ES5有两种声明变量的方法，var命令 和function命令。 ES6除了以上两种方法外还有：let命令、const命令、import命令、class命令 varES5中最原始的变量声明，用于声明变量，其实JavaScript是弱类型语言，对数据类型变量要求不太严格，所以不必声明每一个变量的类型（这就是下面说的隐式声明，当然这并不是一个好习惯），在使用变量之前先进行声明是一种好的习惯。 1.作用域使用var声明的变量的作用域是函数作用域（在ES5时代，只有函数作用域和全局作用域两种作用域），在一个函数内用var声明的变量，则只在这个函数内有效。 12345function test()&#123; var a; console.log(a);//undefined&#125;console.log(a);//ReferenceError: a is not defined 2.变量声明提升用var声明变量时，只要在一个函数作用域内，无论在什么地方声明变量，都会把变量的声明提升到函数作用域的最前头，所以无论使用变量在变量声明前还是声明后，都不会报错（当然只是声明提前，赋值并没有提前，所以如果使用在声明之前，会输出undefined，但不会报错）。 1234function test()&#123; console.log(a);//undefined var a=3;&#125; 隐式声明当没有声明，直接给变量赋值时，会隐式地给变量声明，此时这个变量作为全局变量存在。 123456function test()&#123; a=3; console.log(a);//3&#125;test();console.log(a);//3 当然要注意，隐式声明的话就没有变量声明提前的功能了，所以下面的使用是会报错的。 1234function test()&#123; console.log(a);//ReferenceError: a is not defined a=3;&#125; function用function声明的是函数对象，作用域与var一样，是函数作用域。 1234567function test()&#123; function a()&#123; console.log('d'); &#125; a();//'d'&#125;a();//ReferenceError: a is not defined 同样，function声明也有变量声明提升，下面是两个特殊的例子： 12345678910111213function hello1(a)&#123; console.log(a); //[Function: a] function a()&#123;&#125; console.log(a);//[Function: a]&#125;hello1('test');function hello2(a)&#123; console.log(a); //test var a=3； console.log(a);//3&#125;hello2('test'); 这里有涉及到函数中形参的声明，我们可以将以上两个例子看成： 123456789101112131415function hello1(a)&#123; var a='test； console.log(a); //[Function: a] function a()&#123;&#125; console.log(a);//[Function: a]&#125;hello1('test');function hello2(a)&#123; var a='test； console.log(a); //test var a=3； console.log(a);//3&#125;hello2('test'); 可以看到函数对象的声明也提前了，但是在形参变量声明之后（形参的变量声明在所有声明之前）。 当函数对象和普通对象同时声明时，函数对象的声明提前在普通对象之后。 123456function test()&#123; console.log(a);//[Function: a] function a()&#123;&#125; var a; console.log(a);//[Function: a]&#125; letES6新增的声明变量的关键字，与var类似。 当然，与var也有很大区别： 1.作用域不同let声明的变量的作用域是块级作用域（之前的js并没有块级作用域，只有函数作用域和全局作用域），var声明的变量的作用域是函数作用域。 1234567&#123; let a = 10; var b = 1;&#125;a // ReferenceError: a is not defined.b // 1 2.不存在变量声明提升用var声明变量时，只要在一个函数作用域内，无论在什么地方声明变量，都会把变量的声明提升到函数作用域的最前头，所以无论使用变量在变量声明前还是声明后，都不会报错。而let不一样，与java以及其他语言一样，let声明的变量，在未声明之前变量是不存在的。（js的语法越来越向java靠拢） 12345console.log(a); // undefined,但是不报错。console.log(b); // ReferenceError: b is not defined.var a = 2;let b = 2; 注意：在使用babel时可能会遇到这样的情况： 12console.log(b); //undefinedlet b = 2; babel在翻译es6时，似乎直接将let变为了var，所以运行时也有变量声明提升了，但是在Chrome下运行时是正确的 3.暂时性死区所谓暂时性死区，意思是，在一个块级作用域中，变量唯一存在，一旦在块级作用域中用let声明了一个变量，那么这个变量就唯一属于这个块级作用域，不受外部变量的影响，如下面所示。 无论在块中的任何地方声明了一个变量，那么在这个块级作用域中，任何使用这个名字的变量都是指这个变量，无论外部是否有其他同名的全局变量。 暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。 暂时性死区的意义也是让我们标准化代码，将所有变量的声明放在作用域的最开始。 12345var a = 123; &#123; console.log(a);//ReferenceError let a;&#125; 4.不允许重复声明在相同的作用域内，用let声明变量时，只允许声明一遍。 （var是可以多次声明的） 1234567891011121314151617// 正确function () &#123; var a = 10; var a = 1;&#125;// 报错，Duplicate declaration "a"function () &#123; let a = 10; var a = 1;&#125;// 报错,Duplicate declaration "a"function () &#123; let a = 10; let a = 1;&#125; importES6采用import来代替node等的require来导入模块。 import {$} from &#39;./jquery.js&#39;$对象就是jquery中export暴露的对象。 import命令接受一个对象（用大括号表示），里面指定要从其他模块导入的变量名。注意：大括号里面的变量名，必须与被导入模块对外接口的名称相同。 如果想为输入的变量重新取一个名字，import命令要使用as关键字，将输入的变量重命名。 import { New as $ } from &#39;./jquery.js&#39;;注意，import命令具有提升效果，会提升到整个模块的头部，首先执行。 classES6引入了类的概念，有了class这个关键字，当然，类只是基于原型的面向对象模式的语法糖，为了方便理解和开发而已，类的实质还是函数对象，类中的方法和对象其实都是挂在对应的函数对象的prototype属性下。 我们定义一个类： 12345678910//定义类class Person &#123; constructor(name, age) &#123; this.name = name; this.age = age; &#125; setSex(_sex) &#123; this.sex=_sex; &#125;&#125; constructor方法，就是构造方法，也就是ES5时代函数对象的主体，而this关键字则代表实例对象，将上述类改写成ES5格式就是： 12345678function Person(name, age)&#123; this.name = name; this.age = age;&#125;Person.prototype. setSex = function (_sex) &#123; this.sex=_sex;&#125; 所以说，类不算什么新玩意，大多数类的特性都可以通过之前的函数对象与原型来推导。 1.所有类都有constructor函数，如果没有显式定义，一个空的constructor方法会被默认添加（有点类似java了）。当然所有函数对象都必须有个主体。 2.生成类的实例对象的写法，与ES5通过构造函数生成对象完全一样，也是使用new命令。 12class B &#123;&#125;let b = new B(); 3.在类的实例上面调用方法，其实就是调用原型上的方法，因为类上的方法其实都是添加在原型上。 1b.constructor === B.prototype.constructor // true 4.与函数对象一样，Class也可以使用表达式的形式定义。 12345let Person = class Me &#123; getClassName() &#123; return Me.name; &#125;&#125;; 相当于 1var Person = function test()&#123;&#125; 5.Class其实就是一个function，但是有一点不同，Class不存在变量提升，也就是说Class声明定义必须在使用之前。 全局变量全局对象是最顶层的对象，在浏览器环境指的是window对象，在Node.js指的是global对象。 ES5之中，全局对象的属性与全局变量是等价的，隐式声明或者在全局环境下声明的变量是挂在全局对象上的。 ES6规定，var命令，function命令以及隐式声明的全局变量，依旧是全局对象的属性；而let命令、const命令、class命令声明的全局变量，不属于全局对象的属性。 12345var a = 1;console.log(window.a) // 1let b = 1;console.log(window.b) // undefined 函数的形参函数的形参，隐藏着在函数一开始声明了这些形参对应的变量。 function a(x,y){} 可以看成 1234function a()&#123; var x=arguments.length &lt;= 0 || arguments[0] === undefined ? undefined : arguments[0]; var y=arguments.length &lt;= 1 || arguments[1] === undefined ? undefined : arguments[1];&#125; 当然在ES6下默认声明就是用的let了，所以函数a变成： 1234function a()&#123; let x=arguments.length &lt;= 0 || arguments[0] === undefined ? undefined : arguments[0]; let y=arguments.length &lt;= 1 || arguments[1] === undefined ? undefined : arguments[1];&#125; 所以在ES6中会有以下几个问题： 12345function a(x = y, y = 2) &#123; return [x, y];&#125;a(); // 报错，给X赋值时y还未被let声明。 function a(x，y) { let x;//相当于重复声明，报错。}]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript中call]]></title>
    <url>%2Fhexo%2F2017%2F03%2F22%2Fcall%2F</url>
    <content type="text"><![CDATA[callcall() 方法调用一个函数, 其具有一个指定的this值和分别地提供的参数(参数的列表)。 语法fun.call(thisArg[, arg1[, arg2[, …]]]) 参数thisArg在fun函数运行时指定的this值。需要注意的是，指定的this值并不一定是该函数执行时真正的this值，如果这个函数处于非严格模式下，则指定为null和undefined的this值会自动指向全局对象(浏览器中就是window对象)，同时值为原始值(数字，字符串，布尔值)的this会指向该原始值的自动包装对象。 arg1, arg2, …指定的参数列表。 返回值返回结果包括指定的this值和参数。 描述可以让call()中的对象调用当前对象所拥有的function。你可以使用call()来实现继承：写一个方法，然后让另外一个新的对象来继承它（而不是在新对象中再写一次这个方法）。 示例使用call方法调用父构造函数在一个子构造函数中，你可以通过调用父构造函数的 call 方法来实现继承，类似于Java中的写法。下例中，使用 Food 和 Toy 构造函数创建的对象实例都会拥有在 Product 构造函数中添加的 name 属性和 price 属性,但 category 属性是在各自的构造函数中定义的。 1234567891011121314151617181920212223242526272829303132333435function Product(name, price) &#123; this.name = name; this.price = price; if (price &lt; 0) &#123; throw RangeError('Cannot create product ' + this.name + ' with a negative price'); &#125;&#125;function Food(name, price) &#123; Product.call(this, name, price); this.category = 'food';&#125;//等同于function Food(name, price) &#123; this.name = name; this.price = price; if (price &lt; 0) &#123; throw RangeError('Cannot create product ' + this.name + ' with a negative price'); &#125; this.category = 'food'; &#125;//function Toy 同上function Toy(name, price) &#123; Product.call(this, name, price); this.category = 'toy';&#125;var cheese = new Food('feta', 5);var fun = new Toy('robot', 40); 使用call方法调用匿名函数在下例中的for循环体内，我们创建了一个匿名函数，然后通过调用该函数的call方法，将每个数组元素作为指定的this值执行了那个匿名函数。这个匿名函数的主要目的是给每个数组元素对象添加一个print方法，这个print方法可以打印出各元素在数组中的正确索引号。当然，这里不是必须得让数组元素作为this值传入那个匿名函数（普通参数就可以），目的是为了演示call的用法。 12345678910111213var animals = [ &#123;species: 'Lion', name: 'King'&#125;, &#123;species: 'Whale', name: 'Fail'&#125;];for (var i = 0; i &lt; animals.length; i++) &#123; (function (i) &#123; this.print = function () &#123; console.log('#' + i + ' ' + this.species + ': ' + this.name); &#125; this.print(); &#125;).call(animals[i], i);&#125; 使用call方法调用函数并且指定上下文的’this’在下面的例子中，当调用 greet 方法的时候，该方法的 this 值会绑定到 i 对象。 12345678910function greet() &#123; var reply = [this.person, 'Is An Awesome', this.role].join(' '); console.log(reply);&#125;var i = &#123; person: 'Douglas Crockford', role: 'Javascript Developer'&#125;;greet.call(i); // Douglas Crockford Is An Awesome Javascript Developer]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>call</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript中bind]]></title>
    <url>%2Fhexo%2F2017%2F03%2F21%2Fbind%2F</url>
    <content type="text"><![CDATA[bindbind()方法创建一个新的函数, 当被调用时，将其this关键字设置为提供的值，在调用新函数时，在任何提供之前提供一个给定的参数序列。 bind和call、apply的使用区别： 都是用来改变函数的this对象的指向的； 第一个参数都是this要指向的对象； 都可以利用后续参数传参； bind是返回对应函数，便于稍后调用；apply、call是立即调用。 语法1fun.bind(thisArg[, arg1[, arg2[, ...]]]) 参数thisArg当绑定函数被调用时，该参数会作为原函数运行时的 this 指向。当使用new 操作符调用绑定函数时，该参数无效。 arg1, arg2…当绑定函数被调用时，这些参数将置于实参之前传递给被绑定的方法。 返回值返回由指定的this值和初始化参数改造的原函数拷贝 描述bind() 函数会创建一个新函数（称为绑定函数），新函数与被调函数（绑定函数的目标函数）具有相同的函数体（在 ECMAScript 5 规范中内置的call属性）。当目标函数被调用时 this 值绑定到 bind() 的第一个参数，该参数不能被重写。绑定函数被调用时，bind() 也接受预设的参数提供给原函数。一个绑定函数也能使用new操作符创建对象：这种行为就像把原函数当成构造器。提供的 this 值被忽略，同时调用时的参数被提供给模拟函数。 示例创建绑定函数bind() 最简单的用法是创建一个函数，使这个函数不论怎么调用都有同样的 this 值。JavaScript新手经常犯的一个错误是将一个方法从对象中拿出来，然后再调用，希望方法中的 this 是原来的对象。（比如在回调中传入这个方法。）如果不做特殊处理的话，一般会丢失原来的对象。从原来的函数和原来的对象创建一个绑定函数，则能很漂亮地解决这个问题： 123456789101112131415this.x = 9;var module = &#123; x: 81, getX: function() &#123; return this.x; &#125;&#125;;module.getX(); // 返回 81var retrieveX = module.getX;retrieveX(); // 返回 9, 在这种情况下，"this"指向全局作用域// 创建一个新函数，将"this"绑定到module对象// 新手可能会被全局的x变量和module里的属性x所迷惑var boundGetX = retrieveX.bind(module);boundGetX(); // 返回 81 偏函数（Partial Functions）bind()的另一个最简单的用法是使一个函数拥有预设的初始参数。这些参数（如果有的话）作为bind()的第二个参数跟在this（或其他对象）后面，之后它们会被插入到目标函数的参数列表的开始位置，传递给绑定函数的参数会跟在它们的后面。 1234567891011function list() &#123; return Array.prototype.slice.call(arguments);&#125;var list1 = list(1, 2, 3); // [1, 2, 3]// Create a function with a preset leading argumentvar leadingThirtysevenList = list.bind(undefined, 37);var list2 = leadingThirtysevenList(); // [37]var list3 = leadingThirtysevenList(1, 2, 3); // [37, 1, 2, 3] 配合 setTimeout在默认情况下，使用 window.setTimeout() 时，this 关键字会指向 window （或全局）对象。当使用类的方法时，需要 this 引用类的实例，你可能需要显式地把 this 绑定到回调函数以便继续使用实例。 12345678910111213141516function LateBloomer() &#123; this.petalCount = Math.ceil(Math.random() * 12) + 1;&#125;// Declare bloom after a delay of 1 secondLateBloomer.prototype.bloom = function() &#123; window.setTimeout(this.declare.bind(this), 1000);&#125;;LateBloomer.prototype.declare = function() &#123; console.log(&apos;I am a beautiful flower with &apos; + this.petalCount + &apos; petals!&apos;);&#125;;var flower = new LateBloomer();flower.bloom(); // 一秒钟后, 调用&apos;declare&apos;方法 作为构造函数使用的绑定函数警告 :这部分演示了 JavaScript 的能力并且记录了 bind() 的超前用法。以下展示的方法并不是最佳的解决方案且可能不应该用在任何生产环境中。 自然而然地，绑定函数适用于用new操作符 new 去构造一个由目标函数创建的新的实例。当一个绑定函数是用来构建一个值的，原来提供的 this 就会被忽略。然而, 原先提供的那些参数仍然会被前置到构造函数调用的前面。 12345678910111213141516171819202122232425function Point(x, y) &#123; this.x = x; this.y = y;&#125;Point.prototype.toString = function() &#123; return this.x + ',' + this.y; &#125;;var p = new Point(1, 2);p.toString(); // '1,2'var emptyObj = &#123;&#125;;var YAxisPoint = Point.bind(emptyObj, 0/*x*/);// 以下这行代码在 polyfill 不支持,// 在原生的bind方法运行没问题://(译注：polyfill的bind方法如果加上把bind的第一个参数，即新绑定的this执行Object()来包装为对象，Object(null)则是&#123;&#125;，那么也可以支持)var YAxisPoint = Point.bind(null, 0/*x*/);var axisPoint = new YAxisPoint(5);axisPoint.toString(); // '0,5'axisPoint instanceof Point; // trueaxisPoint instanceof YAxisPoint; // truenew Point(17, 42) instanceof YAxisPoint; // true 你知道不需要做特别的处理就可以用new操作符 new 创建一个绑定函数。必然地，你需要知道不需要做特别处理就可以创建一个可以被直接调用的绑定函数，即使你更希望绑定函数是用new操作符 new 来调用。 12345678// 这个例子可以直接在你的 javascript 控制台运行// ...接着上面的代码继续(译注：// 仍然能作为一个普通函数来调用// (即使通常来说这个不是被期望发生的)YAxisPoint(13);emptyObj.x + &apos;,&apos; + emptyObj.y; // &apos;0,13&apos; 如果你希望一个绑定函数只支持使用new操作符 new，或者只能直接调用它，那么模板函数必须强制执行那限制。 快捷调用在你想要为一个需要特定的 this 值的函数创建一个捷径（shortcut）的时候，bind() 方法也很好用。 你可以用 Array.prototype.slice 来将一个类似于数组的对象（array-like object）转换成一个真正的数组，就拿它来举例子吧。你可以创建这样一个捷径： 12345var slice = Array.prototype.slice;// ...slice.apply(arguments); 用 bind() 可以使这个过程变得简单。在下面这段代码里面，slice 是 Function.prototype 的 call() 方法的绑定函数，并且将 Array.prototype 的 slice() 方法作为 this 的值。这意味着我们压根儿用不着上面那个 apply() 调用了。 123456789101112// same as &quot;slice&quot; in the previous examplevar unboundSlice = Array.prototype.slice;var slice = Function.prototype.call.bind(unboundSlice);// ...slice(arguments);// == Function.prototype.call(unboundSlice,arguments) ===&gt;// [[Call]](unbundSlice,arguments)var str = Function.prototype.call.bind(Object.prototype.toString);str([]) //&apos;[object Array]&apos; 再次认识Function.prototype.call Polyfill（兼容旧浏览器）bind 函数在 ECMA-262 第五版才被加入；它可能无法在所有浏览器上运行。你可以部份地在脚本开头加入以下代码，就能使它运作，让不支持的浏览器也能使用 bind() 功能。 123456789101112131415161718192021222324if (!Function.prototype.bind) &#123; Function.prototype.bind = function (oThis) &#123; if (typeof this !== "function") &#123; // closest thing possible to the ECMAScript 5 // internal IsCallable function throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable"); &#125; var aArgs = Array.prototype.slice.call(arguments, 1), fToBind = this, fNOP = function () &#123;&#125;, fBound = function () &#123; return fToBind.apply(this instanceof fNOP ? this : oThis || this, aArgs.concat(Array.prototype.slice.call(arguments))); &#125;; fNOP.prototype = this.prototype; fBound.prototype = new fNOP(); return fBound; &#125;;&#125; 上述算法和实际的实现算法还有许多其他的不同 （尽管可能还有其他不同之处，却没有那个必要去穷尽）： 这部分实现依赖于Array.prototype.slice()， Array.prototype.concat()， Function.prototype.call()这些原生方法。 这部分实现创建的函数的实现并没有caller 以及会在 get，set或者deletion上抛出TypeError错误的 arguments 属性这两个不可改变的“毒药” 。（假如环境支持{jsxref(“Object.defineProperty”)}}， 或者实现支持defineGetter and defineSetter 扩展） 这部分实现创建的函数有 prototype 属性。（正确的绑定函数没有的） 这部分实现创建的绑定函数所有的 length 属性并不是同ECMA-262标准一致的：它的 length 是0，而在实际的实现中根据目标函数的 length 和预先指定的参数个数可能会返回非零的 length。 如果你选择使用这部分实现，你不能依赖于ECMA-262，但是ECMA-5是可以的。在某些情况下（也可以作另一番修改以适应特定的需要），这部分实现也许可以作为一个过渡，在bind()函数被广泛支持之前。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>bind</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript中apply]]></title>
    <url>%2Fhexo%2F2017%2F03%2F20%2Fapply%2F</url>
    <content type="text"><![CDATA[applyapply() 方法调用一个函数, 其具有一个指定的this值，以及作为一个数组（或类似数组的对象）提供的参数。 注意：call()方法的作用和 apply() 方法类似，只有一个区别，就是 call()方法接受的是若干个参数的列表，而apply()方法接受的是一个包含多个参数的数组。 语法1fun.apply(thisArg, [argsArray]) 参数thisArg在 fun 函数运行时指定的 this 值。需要注意的是，指定的 this 值并不一定是该函数执行时真正的 this 值，如果这个函数处于非严格模式下，则指定为 null 或 undefined 时会自动指向全局对象（浏览器中就是window对象），同时值为原始值（数字，字符串，布尔值）的 this 会指向该原始值的自动包装对象。 argsArray一个数组或者类数组对象，其中的数组元素将作为单独的参数传给 fun 函数。如果该参数的值为null 或 undefined，则表示不需要传入任何参数。从ECMAScript 5 开始可以使用类数组对象。浏览器兼容性请参阅本文底部内容。 描述在调用一个存在的函数时，你可以为其指定一个 this 对象。 this 指当前对象，也就是正在调用这个函数的对象。 使用 apply， 你可以只写一次这个方法然后在另一个对象中继承它，而不用在新对象中重复写该方法。 apply 与 call() 非常相似，不同之处在于提供参数的方式。apply 使用参数数组而不是一组参数列表（原文：a named set of parameters）。apply 可以使用数组字面量（array literal），如 fun.apply(this, [‘eat’, ‘bananas’])，或数组对象， 如 fun.apply(this, new Array(‘eat’, ‘bananas’))。 你也可以使用 arguments 对象作为 argsArray 参数。 arguments 是一个函数的局部变量。 它可以被用作被调用对象的所有未指定的参数。 这样，你在使用apply函数的时候就不需要知道被调用对象的所有参数。 你可以使用arguments来把所有的参数传递给被调用对象。 被调用对象接下来就负责处理这些参数。 从 ECMAScript 第5版开始，可以使用任何种类的类数组对象，就是说只要有一个 length 属性和[0…length) 范围的整数属性。例如现在可以使用 NodeList 或一个自己定义的类似 {‘length’: 2, ‘0’: ‘eat’, ‘1’: ‘bananas’} 形式的对象。 需要注意：Chrome 14 以及 Internet Explorer 9 仍然不接受类数组对象。如果传入类数组对象，它们会抛出异常。 示例使用apply来链接构造器你可以使用apply来给一个对象链接构造器，类似于Java. 在接下来的例子中我们会创建一个叫做construct的全局的Function函数,来使你能够在构造器中使用一个类数组对象而非参数列表。 12345Function.prototype.construct = function (aArgs) &#123; var oNew = Object.create(this.prototype); this.apply(oNew, aArgs); return oNew;&#125;; 注意: 上面使用的Object.create()方法相对来说比较新。另一种可选的方法是使用闭包，请考虑如下替代方法： 1234567Function.prototype.construct = function(aArgs) &#123; var fConstructor = this, fNewConstr = function() &#123; fConstructor.apply(this, aArgs); &#125;; fNewConstr.prototype = fConstructor.prototype; return new fNewConstr();&#125;; 使用案例： 123456789101112function MyConstructor () &#123; for (var nProp = 0; nProp &lt; arguments.length; nProp++) &#123; this["property" + nProp] = arguments[nProp]; &#125;&#125;var myArray = [4, "Hello world!", false];var myInstance = MyConstructor.construct(myArray);console.log(myInstance.property1); // logs "Hello world!"console.log(myInstance instanceof MyConstructor); // logs "true"console.log(myInstance.constructor); // logs "MyConstructor" 注意： 这个非native的Function.construct方法无法和一些native构造器（例如Date）一起使用。 在这种情况下你必须使用Function.bind方法（例如，想象有如下一个数组要用在Date构造器中： [2012, 11, 4]；这时你需要这样写： new (Function.prototype.bind.apply(Date, [null].concat([2012, 11, 4])))() – -无论如何这不是最好的实现方式并且也许不该用在任何生产环境中). 使用apply和内置函数聪明的apply用法允许你在某些本来需要写成遍历数组变量的任务中使用内建的函数。在接下里的例子中我们会使用Math.max/Math.min来找出一个数组中的最大/最小值。 12345678910111213141516/* min/max number in an array */var numbers = [5, 6, 2, 3, 7];/* using Math.min/Math.max apply */var max = Math.max.apply(null, numbers); /* This about equal to Math.max(numbers[0], ...) or Math.max(5, 6, ..) */var min = Math.min.apply(null, numbers);/* vs. simple loop based algorithm */max = -Infinity, min = +Infinity;for (var i = 0; i &lt; numbers.length; i++) &#123; if (numbers[i] &gt; max) max = numbers[i]; if (numbers[i] &lt; min) min = numbers[i];&#125; 但是当心：如果用上面的方式调用 apply, 你很可能会遇到方法参数个数越界的问题. 当你对一个方法传入非常多的参数 (比如超过1W多个参数) 时, 就非常有可能会导致越界问题, 这个临界值是根据不同的 JavaScript 引擎而定的 (JavaScript 核心中已经做了硬编码 参数个数限制在65536)，因为这个限制(实际上也是任何用到超大栈空间的行为的自然表现)是未指定的. 有些引擎会抛出异常. 更糟糕的是其他引擎会直接限制传入到方法的参数个数，导致参数丢失. (举个例子: 如果某个引擎限制了方法参数最多为4个 [实际真正的参数个数限制当然要高得多了, 这里只是打个比方], 上面的代码中, 真正通过 apply 传到目标方法中的参数为 5, 6, 2, 3, 而不是完整的 numbers 数组.) 如果你的参数数组可能非常大, 那么推荐使用下面这种策略来处理: 将参数数组切块后循环传入目标方法: 12345678910111213function minOfArray(arr) &#123; var min = Infinity; var QUANTUM = 32768; for (var i = 0, len = arr.length; i &lt; len; i += QUANTUM) &#123; var submin = Math.min.apply(null, arr.slice(i, Math.min(i + QUANTUM, len))); min = Math.min(submin, min); &#125; return min;&#125;var min = minOfArray([5, 6, 2, 3, 7]); 在”monkey-patching”中使用applyApply可以作为monkey-patch一个Firefox或JS库内建函数的最好方式。对于someobject.foo 函数，你可以用一种旁门左道的方式来修改这个函数，像这样： 12345678var originalfoo = someobject.foo;someobject.foo = function() &#123; //在调用函数前干些什么 console.log(arguments); //像正常调用这个函数一样来进行调用： originalfoo.apply(this,arguments); //在这里做一些调用之后的事情。&#125;]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>apply</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript中this技巧]]></title>
    <url>%2Fhexo%2F2017%2F03%2F18%2Fjavascript%E4%B8%ADthis%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[this绑定机制1. 默认绑定首先介绍的是函数调用类型：独立函数调用，在没有其他应用下的默认规则。这时候this指向了window。 12345678function foo()&#123; var a = 2; function bar()&#123; console.log(this.a) &#125; bar();&#125;foo();// undefined 这段代码中,foo函数中的bar函数运行时，由于默认绑定，this指向window，a未定义导致输出为undefined。下面代码中foo函数输出0，印证了这一点。 123456789var a = 0;function foo()&#123; var a = 2; function bar()&#123; console.log(this.a) &#125; bar();&#125;foo();// 0 2. 隐式绑定另一条规则是调用的位置是否有上下文对象，或者说是否被某个对象拥有或者包含，不过这种说法可能会造成一些误导。 123456789101112function foo()&#123; console.log(this.a);&#125;var obj = &#123; a:2, foo:foo&#125;var objContainer = &#123; a:12, obj:obj&#125;objContainer.obj.foo();//2 首先需要注意的是foo()的声明方式，及其之后是如何被当作引用属性添加到obj中的，但是无论是直接在obj中定义还是先定义再添加引用属性，这个函数严格来说都不属于obj对象。 然而，调用位置会使用obj上下文来引用函数，因此你可以说函数被调用时obj对象“拥有”或者“包含”它。 无论你如何称呼，当foo()被调用时，它的前面确实加上了对obj的引用，隐式绑定规则会把函数调用中的this绑定到这个上下文对象。 对象属性引用链只有上一层或者说最后一层在调用中起作用。简单地说，foo函数中this指向调用它的对象。 3. 隐式丢失123456789101112function foo()&#123; console.log(this.a);&#125;var obj = &#123; a : 2， foo : foo&#125;var bar = obj.foo;var a = "suprise";bar ();//suprise 这种情况中，bar函数输出的是”suprise”，this改变了，obj中的a变量丢失了。 1234567891011121314151617function foo()&#123; console.log(this.a);&#125;function doFoo(fn)&#123; var a = 3; fn();&#125;var obj = &#123; a : 2, foo:foo&#125;var a = "hello world";doFoo(obj.foo)//hello world foo函数被doFoo调用，obj中的a变量丢失。 事实上，个人这种情况和默认绑定有类似，当一个函数独立被调用，而不是被一个对象调用，this都指向了window。 1234567891011function foo()&#123; console.log(this);&#125;function doFoo(fn)&#123; fn();&#125;var obj = &#123; a : 2, foo:foo&#125;doFoo(obj.foo)//Window&#123;...&#125; 4. 显示绑定学bind()\apply()\call()函数，接收的第一个参数即是上下文对象并将其赋给this。 1234567891011121314function foo()&#123; console.log(this.a);&#125;function doFoo(fn)&#123; fn.call(obj);&#125;var obj = &#123; a : 2, foo:foo&#125;var a = "hello world";doFoo(obj.foo) // 2 5. new新对象绑定如果是一个构造函数，那么用new来调用，那么绑定的将是新创建的对象。 12345function fn(a) &#123; this.a = a;&#125;var bar = new fn( 2 );console.log( bar.a );// 2 6. 小结 当函数被一个对象调用，this指向函数最近的对象； :smirk: 当函数被独立调用，this指向Window； call，apply 中指向谁，this就指向谁。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>this</tag>
      </tags>
  </entry>
</search>
